<?xml version="1.0" encoding="utf-8"?>
<rules>
  <rule>
    <key>S3244</key>
    <name>Anonymous delegates should not be used to unsubscribe from Events</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    It is possible to subscribe to events with anonymous delegates, but having done so, it is impossible to unsubscribe from them.
    That's because the process of subscribing adds the delegate to a list. The process of unsubscribing essentially says: remove
    this item from the subscription list. But because an anonymous delegate was used in both cases, the unsubscribe attempt tries
    to remove a different item from the list than was added. The result: <code>NOOP</code>.
</p>
<p>
    Instead, save the delegate to a variable and use the variable to subscribe and unsubscribe.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
listView.PreviewTextInput += (obj,args) =>
        listView_PreviewTextInput(obj,args,listView);

// ...

listView.PreviewTextInput -= (obj, args) =>
        listView_PreviewTextInput(obj, args, listView); // Noncompliant; this delegate was never subscribed
</pre>

<h2>Compliant Solution</h2>
<pre>
EventHandler func = (obj,args) => listView_PreviewTextInput(obj,args,listView);

listView.PreviewTextInput += func;

// ...

listView.PreviewTextInput -= func;
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S3236</key>
    <name>Methods with caller info attributes should not be invoked with explicit arguments</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Caller information attributes (<code>CallerFilePathAttribute</code>, <code>CallerLineNumberAttribute</code>, and
    <code>CallerMemberNameAttribute</code>) provide a way to get information about the caller of a method through optional parameters.
    But the arguments for these optional parameters are only generated if they are not explicitly defined in the call. Thus, specifying
    the argument values defeats the purpose of the attributes.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
void TraceMessage(string message,
  [CallerMemberName] string memberName = "",
  [CallerFilePath] string filePath = "",
  [CallerLineNumber] int lineNumber = 0)
{
  /* ... */
}

void MyMethod()
{
  TraceMessage("my message", "MyMethod"); // Noncompliant
}
</pre>

<h2>Compliant Solution</h2>
<pre>
void TraceMessage(string message,
  [CallerMemberName] string memberName = "",
  [CallerFilePath] string filePath = "",
  [CallerLineNumber] int lineNumber = 0)
{
  /* ... */
}

void MyMethod()
{
  TraceMessage("my message");
}
</pre>
]]></description>
    <tag>suspicious</tag>
  </rule>
  <rule>
    <key>S2330</key>
    <name>Array covariance should not be used</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Array covariance is the principle that if an implicit or explicit reference conversion exits from type <code>A</code> to
    <code>B</code>, then the same conversion exists from the array type <code>A[]</code> to <code>B[]</code>.
</p>
<p>
    While this array conversion can be useful in readonly situations to pass instances of <code>A[]</code> wherever
    <code>B[]</code> is expected, it must be used with care, since assigning an instance of <code>B</code> into an array of
    <code>A</code> will cause an <code>ArrayTypeMismatchException</code> to be thrown at runtime.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
abstract class Fruit { }
class Apple : Fruit { }
class Orange : Fruit { }

class Program
{
  static void Main(string[] args)
  {
    Fruit[] fruits = new Apple[1]; // Noncompliant - array covariance is used
    FillWithOranges(fruits);
  }

  // Just looking at the code doesn't reveal anything suspicious
  static void FillWithOranges(Fruit[] fruits)
  {
    for (int i = 0; i < fruits.Length; i++)
    {
      fruits[i] = new Orange(); // Will throw an ArrayTypeMismatchException
    }
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
abstract class Fruit { }
class Apple : Fruit { }
class Orange : Fruit { }

class Program
{
  static void Main(string[] args)
  {
    Orange[] fruits = new Orange[1]; // Compliant
    FillWithOranges(fruits);
  }

  static void FillWithOranges(Orange[] fruits)
  {
    for (int i = 0; i < fruits.Length; i++)
    {
      fruits[i] = new Orange();
    }
  }
}
</pre>
]]></description>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S1121</key>
    <name>Assignments should not be made from within sub-expressions</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Assignments within sub-expressions are hard to spot and therefore make the code less readable.
    It is also a common mistake to write <code>=</code> when <code>==</code> was meant.
    Ideally, expressions should should not have side-effects.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
doSomething(i = 42);
</pre>

<h2>Compliant Solution</h2>
<pre>
i = 42;
doSomething(i);
// or
doSomething(i == 42);  // Perhaps in fact the comparison operator was expected
</pre>

<h2>Exceptions</h2>
Assignments inside lambda and delegate expressions are allowed.

<h2>See</h2>
<ul>
    <li>MISRA C:2004, 13.1 - Assignment operators shall not be used in expressions that yield a Boolean value</li>
    <li>MISRA C++:2008, 6-2-1 - Assignment operators shall not be used in sub-expressions</li>
    <li>MISRA C:2012, 13.4 - The result of an assignment operator should not be used</li>
    <li><a href="http://cwe.mitre.org/data/definitions/481.html">MITRE, CWE-481</a> - Assigning instead of Comparing</li>
</ul>]]></description>
    <tag>suspicious</tag>
    <tag>cwe</tag>
    <tag>misra</tag>
  </rule>
  <rule>
    <key>S3168</key>
    <name>"async" methods should not return "void"</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    An async method with a void return type is a "fire and forget" method best reserved for event handlers because there's no way to wait for the method's execution to complete and respond accordingly. There's also no way to catch exceptions thrown from the method.
</p>
<p>
    Having an async void method that is not an event handler could mean your program works some times and not others because of timing issues. Instead, async methods should return Task.
</p>
<p>
    This rule raises an issue when non-event handler methods are both async and void.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
class HttpPrinter
{
  private string content;

  public async void CallNetwork(string url) //Noncompliant
  {
    var client = new HttpClient();
    var response = await client.GetAsync(url);
    content = await response.Content.ReadAsStringAsync();
  }

  public async Task PrintContent(string url)  // works correctly if web request finishes in under 1 second, otherwise content will be null
  {
    CallNetwork(url);
    await Task.Delay(1000);
    Console.Write(content);
  }
}
</pre>

<h2>Compliant Solution</h2>

<pre>
class HttpPrinter
{
  private string content;

  public async Task CallNetwork(string url)
  {
    var client = new HttpClient();
    var response = await client.GetAsync(url);
    content = await response.Content.ReadAsStringAsync();
  }

  public async Task PrintContent(string url)
  {
    await CallNetwork(url); // &lt;----- call changed here. If await is not added warning CS4014 will be triggered
    await Task.Delay(1000);
    Console.Write(content);
  }
}
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S2306</key>
    <name>"async" and "await" should not be used as identifiers</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
Since C# 5.0, <code>async</code> and <code>await</code> are contextual keywords.
Contextual keywords do have a particular meaning in some contexts, but can still be used as variable names for example.
Keywords, on the other hand, are always reserved, and therefore are not valid variable names.
To avoid any confusion though, it is best to not use <code>async</code> and <code>await</code> as identifiers.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
int await = 42; // Noncompliant
</pre>

<h2>Compliant Solution</h2>
<pre>
int someOtherName = 42;
</pre>
]]></description>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S1764</key>
    <name>Identical expressions should not be used on both sides of a binary operator</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste error and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical operators, having the same value on both sides of an operator yields predictable results, and should be simplified.
</p>
<p>
This rule ignores <code>*</code>, <code>+</code>, and <code>=</code>.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
if ( a == a ) // always true
{
  doZ();
}
if ( a != a ) // always false
{
  doY();
}
if ( a == b &amp;&amp; a == b ) // if the first one is true, the second one is too
{
  doX();
}
if ( a == b || a == b ) // if the first one is true, the second one is too
{
  doW();
}

int j = 5 / 5; //always 1
int k = 5 - 5; //always 0
</pre>

<h2>Compliant Solution</h2>
<pre>
doZ();

if ( a == b )
{
  doX();
}
if ( a == b )
{
  doW();
}

int j = 1;
int k = 0;
</pre>

<h2>Exceptions</h2>
Left-shifting 1 onto 1 is common in the construction of bit masks, and is ignored.
<pre>
int i = 1 << 1; // Compliant
int j = a << a; // Noncompliant
</pre>

<h2>See</h2>

<ul>
    <li> <a href="https://www.securecoding.cert.org/confluence/x/NYA5">CERT, MSC12-C</a> - Detect and remove code that has no effect</li>
    <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP</a> - Detect and remove code that has no effect</li>
    <li>Rule S1656 - Implements a check on <code>=</code>.</li>
</ul>]]></description>
    <tag>bug</tag>
    <tag>cert</tag>
  </rule>
  <rule>
    <key>S1940</key>
    <name>Boolean checks should not be inverted</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    It is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
if ( !(a == 2)) { ... }  // Noncompliant
bool b = !(i < 10);  // Noncompliant
</pre>

<h2>Compliant Solution</h2>
<pre>
if (a != 2) { ... }
bool b = (i >= 10);
</pre>

]]></description>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S1125</key>
    <name>Boolean literals should not be redundant</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Redundant Boolean literals should be removed from expressions to improve readability.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
if (booleanVariable == true) { /* ... */ }
if (booleanVariable != true) { /* ... */ }
if (booleanVariable || false) { /* ... */ }
doSomething(!false);

booleanVariable = condition ? true : exp;
booleanVariable = condition ? false : exp;
booleanVariable = condition ?  exp : true;
booleanVariable = condition ?  exp : false;
booleanVariable = condition ?  true : false;
</pre>

<h2>Compliant Solution</h2>
<pre>
if (booleanVariable) { /* ... */ }
if (!booleanVariable) { /* ... */ }
if (booleanVariable) { /* ... */ }
doSomething(true);

booleanVariable = condition || exp;
booleanVariable = !condition && exp;
booleanVariable = !condition ||  exp;
booleanVariable = condition && exp;
booleanVariable = condition;
</pre>
]]></description>
    <tag>clumsy</tag>
  </rule>
  <rule>
    <key>S1227</key>
    <name>break statements should not be used except for switch cases</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
<code>break;</code> is an unstructured control flow statement which makes code harder to read.
Ideally, every loop should have a single termination condition.
</p>

<h2>Noncompliant Code Example</h2>

<pre>
int i = 0;
while (true)
{
  if (i == 10)
  {
    break;      // Non-Compliant
  }

  Console.WriteLine(i);
  i++;
}
</pre>

<h2>Compliant Solution</h2>

<pre>
int i = 0;
while (i != 10) // Compliant
{
  Console.WriteLine(i);
  i++;
}
</pre>
]]></description>
  </rule>
  <rule>
    <key>S3215</key>
    <name>"interface" instances should not be cast to concrete types</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Needing to cast from an <code>interface</code> to a concrete type indicates that something is wrong with the abstractions in
    use, likely that something is missing from the <code>interface</code>. Instead of casting to a discrete type, the missing
    functionality should be added to the <code>interface</code>. Otherwise there is the risk of runtime exceptions.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public interface IMyInterface
{
  void DoStuff();
}

public class MyClass1 : IMyInterface
{
  public int Data { get { return new Random().Next(); } }

  public void DoStuff()
  {
    // TODO...
  }
}

public static class DowncastExampleProgram
{
  static void EntryPoint(IMyInterface interfaceRef)
  {
    MyClass1 class1 = (MyClass1)interfaceRef;  // Noncompliant
    int privateData = class1.Data;

    class1 = interfaceRef as MyClass1;  // Noncompliant
    if (class1 != null)
    {
      // ...
    }
  }
}
</pre>
]]></description>
    <tag>design</tag>
  </rule>
  <rule>
    <key>S2486</key>
    <name>Exceptions should not be ignored</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
When exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly, or at least to log them.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
string text = "";
try
{
  text = File.ReadAllText(fileName);
}
catch (Exception exc) // Noncompliant
{
}
</pre>

<h2>Compliant Solution</h2>
<pre>
string text = "";
try
{
  text = File.ReadAllText(fileName);
}
catch (Exception exc)
{
  logger.Log(exc);
}
</pre>

<h2>See</h2>

<ul>
    <li> <a href="http://cwe.mitre.org/data/definitions/391.html">MITRE, CWE-391</a> - Unchecked Error Condition</li>
</ul>]]></description>
    <tag>cwe</tag>
    <tag>error-handling</tag>
    <tag>security</tag>
  </rule>
  <rule>
    <key>S2737</key>
    <name>"catch" clauses should do more than rethrow</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
A <code>catch</code> clause that only rethrows the caught exception has the same effect as omitting the <code>catch</code> altogether and letting it bubble up automatically, but with more code and the additional detrement of leaving maintainers scratching their heads.
Such clauses should either be eliminated or populated with the appropriate logic.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
string s = "";
try
{
  s = File.ReadAllText(fileName);
}
catch (Exception e) // Noncompliant
{
  throw;
}
</pre>

<h2>Compliant Solution</h2>
<pre>
string s = "";
try
{
  s = File.ReadAllText(fileName);
}
catch (Exception e)
{
  logger.LogError(e);
  throw;
}
</pre>
or
<pre>
string s = File.ReadAllText(fileName);
</pre>]]></description>
    <tag>clumsy</tag>
    <tag>unused</tag>
  </rule>
  <rule>
    <key>S101</key>
    <name>Class names should comply with a naming convention</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate.
This rule allows to check that all class names match a provided regular expression.
</p>

<h2>Noncompliant Code Example</h2>
<p>With default provided regular expression <code>^([A-HJ-Z][a-zA-Z0-9]+|I[a-z0-9][a-zA-Z0-9]*|[A-Z][a-zA-Z0-9]+Extensions)$</code>:</p>
<pre>
class my_class {...}
</pre>

<h2>Compliant Solution</h2>

<pre>
class MyClass {...}
</pre>]]></description>
    <tag>convention</tag>
    <param>
      <key>format</key>
      <description><![CDATA[Regular expression used to check the class names against.]]></description>
      <type>STRING</type>
      <defaultValue>^([A-HJ-Z][a-zA-Z0-9]+|I[a-z0-9][a-zA-Z0-9]*|[A-Z][a-zA-Z0-9]+Extensions)$</defaultValue>
    </param>
  </rule>
  <rule>
    <key>S1694</key>
    <name>An abstract class should have both abstract and concrete methods</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    The purpose of an abstract class is to provide some heritable behaviors while also defining methods which must be
    implemented by sub-classes.
</p>
<p>
    A class with no abstract methods that was made abstract purely to prevent instantiation should be converted to a
    concrete class (i.e. remove the <code>abstract</code> keyword) with a private constructor.
</p>
<p>
    A class with only abstract methods and no inheritable behavior should be converted to an interface.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public abstract class Animal //Noncompliant; should be an interface
{
  abstract void Move();
  abstract void Feed();
}

public abstract class Color //Noncompliant; should be concrete with a private constructor
{
  private int red = 0;
  private int green = 0;
  private int blue = 0;

  public int GetRed()
  {
    return red;
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public interface Animal
{
  void Move();
  void Feed();
}

public class Color
{
  private int red = 0;
  private int green = 0;
  private int blue = 0;

  private Color()
  {}

  public int GetRed()
  {
    return red;
  }
}

public abstract class Lamp
{
  private bool switchLamp = false;

  public abstract void Glow();

  public void FlipSwitch()
  {
    switchLamp = !switchLamp;
    if (switchLamp)
    {
      Glow();
    }
  }
}
</pre>
]]></description>
    <tag>convention</tag>
  </rule>
  <rule>
    <key>S1118</key>
    <name>Utility classes should not have public constructors</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Utility classes, which are collections of <code>static</code> members, are not meant to be instantiated. Even
    <code>abstract</code> utility classes, which can be extended, should not have <code>public</code> constructors.
</p>
<p>
    C# adds an implicit public constructor to every class which does not explicitly define at least one constructor. Hence, at
    least one <code>protected</code> constructor should be defined if you wish to subclass this utility class. Or the
    <code>static</code> keyword should be added to the class declaration to prevent subclassing.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class StringUtils // Noncompliant
{
  public static string Concatenate(string s1, string s2)
  {
    return s1 + s2;
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public static class StringUtils
{
  public static string Concatenate(string s1, string s2)
  {
    return s1 + s2;
  }
}
</pre>
or
<pre>
public class StringUtils
{
  protected StringUtils()
  {
  }
  public static string Concatenate(string s1, string s2)
  {
    return s1 + s2;
  }
}
</pre>
]]></description>
    <tag>design</tag>
  </rule>
  <rule>
    <key>S1155</key>
    <name>"Any()" should be used to test for emptiness</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Using <code>.Count()</code> to test for emptiness works, but using <code>.Any()</code> makes the intent clearer,
    and the code more readable.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
private static bool HasContent(IEnumerable&lt;string&gt; strings)
{
  return strings.Count() > 0; // Noncompliant
}
private static bool HasContent2(IEnumerable&lt;string&gt; strings)
{
  return strings.Count() >= 1; // Noncompliant
}
private static bool IsEmpty(IEnumerable&lt;string&gt; strings)
{
  return strings.Count() == 0; // Noncompliant
}
</pre>

<h2>Compliant Solution</h2>
<pre>
private static bool HasContent(IEnumerable&lt;string&gt; strings)
{
  return strings.Any();
}

private static bool IsEmpty(IEnumerable&lt;string&gt; strings)
{
  return !strings.Any();
}
</pre>]]></description>
    <tag>clumsy</tag>
  </rule>
  <rule>
    <key>S2971</key>
    <name>"IEnumerable" LINQs should be simplified</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    In the interests of readability, code that can be simplified should be simplified. To that end, there are several
    ways <code>IEnumerable LINQ</code>s can be simplified
</p>
<ul>
    <li>Use <code>OfType</code> instead of using <code>Select</code> with <code>as</code> to type cast elements and then
    null-checking in a query expression to choose elements based on type.</li>
    <li>Use <code>OfType</code> instead of using <code>Where</code> and the <code>is</code> operator, followed by a cast
    in a <code>Select</code></li>
    <li>Use an expression in <code>Any</code> instead of <code>Where(element => [expression]).Any()</code>.</li>
    <li>Use <code>Count</code> instead of <code>Count()</code> when it's available.</li>
    <li>Don't call <code>ToArray()</code> or <code>ToList()</code> in the middle of a query chain.</li>
</ul>

<h2>Noncompliant Code Example</h2>
<pre>
seq1.Select(element => element as T).Any(element => element != null);  // Noncompliant; use OfType
seq2.Select(element => element as T).Any(element => element != null &amp;&amp; CheckCondition(element));  // Noncompliant; use OfType
seq3.Where(element => element is T).Select(element => element as T); // Noncompliant; use OfType
seq4.Where(element => element is T).Select(element => (T)element); // Noncompliant; use OfType
seq.Where(element => [expression]).Any();  // Noncompliant; use Any([expression])
</pre>

<h2>Compliant Solution</h2>
<pre>
seq1.OfType&lt;T&gt;().Any();
seq2.OfType&lt;T&gt;().Any(element => CheckCondition(element));
seq3.OfType&lt;T&gt;();
seq4.OfType&lt;T&gt;();
seq.Any(element => [expression])
</pre>
]]></description>
    <tag>clumsy</tag>
  </rule>
  <rule>
    <key>S3216</key>
    <name>"ConfigureAwait(false)" should be used</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    After an <code>await</code>ed <code>Task</code> has executed, you can continue execution in the original, calling
    thread or any arbitrary thread. Unless the rest of the code needs the context from which the <oode>Task</oode> was
    spawned, <code>Task.ConfigureAwait(false)</code> should be used to keep execution in the <code>Task</code> thread
    to avoid the need of context switching and the possibility of deadlocks.
</p>
<p>
    This rule raises an issue when code in a class library <code>await</code>s a <code>Task</code> and continues
    execution in the original calling thread.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
var response = await httpClient.GetAsync(url);  // Noncompliant
</pre>

<h2>Compliant Solution</h2>
<pre>
var response = await httpClient.GetAsync(url).ConfigureAwait(false);
</pre>
]]></description>
    <tag>multi-threading</tag>
    <tag>suspicious</tag>
  </rule>
  <rule>
    <key>S125</key>
    <name>Sections of code should not be "commented out"</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Programmers should not comment out code as it bloats programs and reduces readability.
    Unused code should be deleted and can be retrieved from source control history if required.
</p>

<h2>See</h2>
<ul>
    <li>MISRA C:2004, 2.4 - Sections of code should not be "commented out".</li>
    <li>MISRA C++:2008, 2-7-2 - Sections of code shall not be "commented out" using C-style comments.</li>
    <li>MISRA C++:2008, 2-7-3 - Sections of code should not be "commented out" using C++ comments.</li>
    <li>MISRA C:2012, Dir. 4.4 - Sections of code should not be "commented out"</li>
</ul>
]]></description>
    <tag>misra</tag>
    <tag>unused</tag>
  </rule>
  <rule>
    <key>S1134</key>
    <name>"FIXME" tags should be handled</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    <code>FIXME</code> tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with
    later.
</p>
<p>
    Sometimes the developer will not have the time or will simply forget to get back to that tag.
</p>
<p>
    This rule is meant to track those tags, and ensure that they do not go unnoticed.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
private int Divide(int numerator, int denominator)
{
  return numerator / denominator;              // FIXME denominator value might be  0
}
</pre>]]></description>
  </rule>
  <rule>
    <key>S1135</key>
    <name>"TODO" tags should be handled</name>
    <severity>INFO</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    <code>TODO</code> tags are commonly used to mark places where some more code is required, but which the
    developer wants to implement later.
</p>
<p>
    Sometimes the developer will not have the time or will simply forget to get back to that tag.
</p>
<p>
    This rule is meant to track those tags, and ensure that they do not go unnoticed.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
private void DoSomething()
{
  // TODO
}
</pre>]]></description>
  </rule>
  <rule>
    <key>S3240</key>
    <name>The simplest possible condition syntax should be used</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    In the interests of keeping code clean, the simplest possible conditional syntax should be used. That means using
    the <code>??</code> operator for an assign-if-not-null operator, and using the ternary operator <code>?:</code> for
    assignment to a single variable.
</p>

<h2>Noncompliant Code Sample</h2>
<pre>
object a = null, b = null, x;

if (a != null) // Noncompliant; needlessly verbose
{
  x = a;
}
else
{
  x = b;
}

x = a != null ? a : b; // Noncompliant; better but could still be simplified

x = (a == null) ? new object() : a; // Noncompliant

if (condition) // Noncompliant
{
  x = a;
}
else
{
  x = b;
}
</pre>

<h2>Compliant Solution</h2>
<pre>
object x;

x = a ?? b;
x = a ?? b;
x = a ?? new object();
x = condition ? a : b;
</pre>]]></description>
    <tag>clumsy</tag>
  </rule>
  <rule>
    <key>S1862</key>
    <name>Related "if/else if" statements should not have the same condition</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
A chain of <code>if</code>/<code>else if</code> statements is evaluated from top to bottom. At most, only one branch will be executed: the first one with a condition that evaluates to <code>true</code>.
Therefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it's simply dead code and at worst, it's a bug that is likely to induce
further bugs as the code is maintained, and obviously it could lead to unexpected behavior.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
if (param == 1)
  openWindow();
else if (param == 2)
  closeWindow();
else if (param == 1)  // Noncompliant
  moveWindowToTheBackground();
</pre>

<h2>Compliant Solution</h2>
<pre>
if (param == 1)
  openWindow();
else if (param == 2)
  closeWindow();
else if (param == 3)
  moveWindowToTheBackground();
</pre>

<h2>See</h2>

<ul>
<li> <a href="https://www.securecoding.cert.org/confluence/x/NYA5">CERT, MSC12-C</a> - Detect and remove code that has no effect</li>
<li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP</a> - Detect and remove code that has no effect</li>
</ul>]]></description>
    <tag>bug</tag>
    <tag>cert</tag>
    <tag>pitfall</tag>
    <tag>unused</tag>
  </rule>
  <rule>
    <key>S1871</key>
    <name>Two branches in the same conditional structure should not have exactly the same implementation</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Having two <code>cases</code> in the same <code>switch</code> statement or branches in the same <code>if</code> structure
    with the same implementation is at best duplicate code, and at worst a coding error. If the same logic is truly needed for
    both instances, then in an <code>if</code> structure they should be combined, or for a <code>switch</code>, one should fall
    through to the other.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
switch (i)
{
  case 1:
    doSomething();
    break;
  case 2:
    doSomethingDifferent();
    break;
  case 3:  // Noncompliant; duplicates case 1's implementation
    doSomething();
    break;
  default:
    doTheRest();
}

if (a >= 0 &amp;&amp; a < 10)
{
  doTheThing();
}
else if (a >= 10 &amp;&amp; a < 20)
{
  doTheOtherThing();
}
else if (a >= 20 &amp;&amp; a < 50)
{
  doTheThing();  // Noncompliant; duplicates first condition
}
else
{
  doTheRest();
}

if (b == 0)
{
  doOneMoreThing();
}
</pre>

<h2>Compliant Solution</h2>
<pre>
switch (i) {
  case 1:
  case 3:
    doSomething();
    break;
  case 2:
    doSomethingDifferent();
    break;
  default:
    doTheRest();
}

if ((a >= 0 &amp;&amp; a < 10) || (a >= 20 &amp;&amp; a < 50))
{
  doTheThing();
}
else if (a >= 10 &amp;&amp; a < 20)
{
  doTheOtherThing();
}
else
{
  doTheRest();
}

doOneMoreThing();
</pre>
or
<pre>
switch (i)
{
  case 1:
    doSomething();
    break;
  case 2:
    doSomethingDifferent();
    break;
  case 3:
    doThirdThing();
    break;
  default:
    doTheRest();
}

if (a >= 0 &amp;&amp; a < 10)
{
  doTheThing();
}
else if (a >= 10 &amp;&amp; a < 20)
{
  doTheOtherThing();
}
else if (a >= 20 &amp;&amp; a < 50)
{
  doTheThirdThing();
}
else
{
  doTheRest();
}
</pre>
]]></description>
    <tag>design</tag>
    <tag>suspicious</tag>
  </rule>
  <rule>
    <key>S2760</key>
    <name>Sequential tests should not check the same condition</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    When the same condition is checked twice in a row, it is either confusing - why have separate checks? - or an error - some other condition
    should have been checked in the second test.
</p>
<h2>Noncompliant Code Example</h2>
<pre>
if (a == b)
{
  doTheThing(b);
}
if (a == b) // Noncompliant; is this really what was intended?
{
  doTheThing(c);
}
</pre>

<h2>Compliant Solution</h2>
<pre>
if (a == b)
{
  doTheThing(b);
  doTheThing(c);
}
</pre>

or

<pre>
if (a == b)
{
  doTheThing(b);
}
if (b == c)
{
  doTheThing(c);
}
</pre>

<h2>Exceptions</h2>
<p>
    Since it is a common pattern to test a variable, reassign it if it fails the test, then re-test it, that pattern is ignored.
</p>]]></description>
    <tag>clumsy</tag>
    <tag>suspicious</tag>
  </rule>
  <rule>
    <key>S2228</key>
    <name>Console logging should not be used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Debug statements are always useful during development. But include them in production code - particularly
    in code that runs client-side - and you run the risk of inadvertently exposing sensitive information.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
private void DoSomething ()
{
  // ...
  Console.WriteLine ("so far, so good..."); // Noncompliant
  // ...
}
</pre>


<h2>See</h2>

<ul>
    <li> <a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure">OWASP Top Ten 2013 Category A6</a> - Sensitive Data Exposure</li>
</ul>]]></description>
    <tag>security</tag>
    <tag>owasp-a6</tag>
  </rule>
  <rule>
    <key>S1699</key>
    <name>Constructors should only call non-overridable methods</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Calling an overridable method from a constructor could result in failures or strange behaviors when instantiating a subclass which overrides the method.
</p>
<p>
    For example:
</p>
<ul>
    <li>The subclass class constructor starts by calling the parent class constructor.</li>
    <li>The parent class constructor calls the method, which has been overridden in the child class.</li>
    <li>
        If the behavior of the child class method depends on fields that are initialized in the child class constructor,
        unexpected behavior (like a <code>NullReferenceException</code>) can result, because the fields aren't initialized yet.
    </li>
</ul>

<h2>Noncompliant Code Example</h2>
<pre>
public class Parent
{
  public Parent()
  {
    DoSomething();  // Noncompliant
  }

  public virtual void DoSomething() // can be overridden
  {
    ...
  }
}

public class Child : Parent
{
  private string foo;

  public Child(string foo) // leads to call DoSomething() in Parent constructor which triggers a NullReferenceException as foo has not yet been initialized
  {
    this.foo = foo;
  }

  public override void DoSomething()
  {
    Console.WriteLine(this.foo.Length);
  }
}
</pre>
]]></description>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S1854</key>
    <name>Dead stores should be removed</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction.
    Calculating or retrieving a value only to then overwrite it or throw it away, could indicate a serious error in
    the code. Even if it's not an error, it is at best a waste of resources. Therefore all calculated values should be used.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
void calculateRate(int a, int b)
{
  int i;

  i = a + b; // Noncompliant; calculation result not used before value is overwritten
  i = doSomething();  // Noncompliant; retrieved value not used
  for (i = 0; i &lt; 10; i++)
  {
    //  ...
  }
  // ...
}
</pre>

<h2>Compliant Solution</h2>
<pre>
void calculateRate(int a, int b)
{
  int i;

  i = doSomething();
  i += a + b;
  storeI(i)

  for (i = 0; i &lt; 10; i++)
  {
    //  ...
  }
}
</pre>

<h2>See</h2>

<ul>
    <li><a href="http://cwe.mitre.org/data/definitions/563.html">MITRE, CWE-563</a> - Assignment to Variable without Use ('Unused Variable')</li>
    <li><a href="https://www.securecoding.cert.org/confluence/x/QYA5">CERT, MSC13-C</a> - Detect and remove unused values</li>
    <li><a href="https://www.securecoding.cert.org/confluence/x/S4IyAQ">CERT, MSC13-CPP</a> - Detect and remove unused values</li>
</ul>
]]></description>
    <tag>suspicious</tag>
    <tag>cert</tag>
    <tag>cwe</tag>
    <tag>unused</tag>
  </rule>
  <rule>
    <key>S3253</key>
    <name>"base()" constructor calls should not be explicitly made</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Since the compiler will automatically invoke the base type's no-argument constructor, there's no need to specify its invocation explicitly. Doing so just clutters the code.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
class X
{
  public X()
  {
    /* ... */
  }
}

class Y : X
{
  public Y(int parameter) : base() // Noncompliant
  {
    /* does something with the parameter */
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
class X
{
  public X()
  {
    /* ... */
  }
}

class Y : X
{
  public Y(int parameter)
  {
    /* does something with the parameter */
  }
}
</pre>
]]></description>
    <tag>clumsy</tag>
  </rule>
  <rule>
    <key>S3172</key>
    <name>Delegates should not be subtracted</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    In C#, delegates can be added together to chain their execution, and subtracted to remove their execution from the chain.
</p>
<p>
    Subtracting a chain of delegates from another one might yield unexpected results as shown hereunder - and is likely to be a bug
</p>

<h2>Noncompliant Code Example</h2>
<pre>
MyDelegate first, second, third, fourth;
first = () => Console.Write("1");
second = () => Console.Write("2");
third = () => Console.Write("3");
fourth = () => Console.Write("4");

MyDelegate chain1234 = first + second + third + fourth; // Compliant - chain sequence = "1234"
MyDelegate chain12 = chain1234 - third - fourth; // Compliant - chain sequence = "12"

// The chain sequence of "chain23" will be "1234" instead of "23"!
// Indeed, the sequence "1234" does not contain the subsequence "14", so nothing is subtracted
// (but note that "1234" contains both the "1" and "4" subsequences)
MyDelegate chain23 = chain1234 - (first + fourth); // Noncompliant

chain23(); // will print "1234"!
</pre>

<h2>Compliant Solution</h2>
<pre>
MyDelegate chain23 = chain1234 - first - fourth; // Compliant - "1" is first removed, followed by "4"

chain23(); // will print "23"
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S2931</key>
    <name>Classes with "IDisposable" members should implement "IDisposable"</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Classes with <code>IDisposable</code> members are responsible for cleaning up those members by calling
    their <code>Dispose</code> methods. The best practice here is for the owning class to itself implement
    <code>IDisposable</code> and call its members' <code>Dispose</code> methods from its own
    <code>Dispose</code> method.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class ResourceHolder   // Noncompliant; doesn't implement IDisposable
{
  private FileStream fs;  // This member is never Dispose'd
  public void OpenResource(string path)
  {
    this.fs = new FileStream(path, FileMode.Open);
  }
  public void CloseResource()
  {
    this.fs.Close();
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public class ResourceHolder : IDisposable
{
  private FileStream fs;
  public void OpenResource(string path)
  {
    this.fs = new FileStream(path, FileMode.Open);
  }
  public void CloseResource()
  {
    this.fs.Close();
  }
  public void Dispose()
  {
    this.fs.Dispose();
  }
}
</pre>

<h2>See</h2>

<ul>
    <li> <a href="http://cwe.mitre.org/data/definitions/459.html">MITRE, CWE-459</a> - Incomplete Cleanup</li>
</ul>
]]></description>
    <tag>bug</tag>
    <tag>cwe</tag>
    <tag>denial-of-service</tag>
    <tag>security</tag>
  </rule>
  <rule>
    <key>S2930</key>
    <name>"IDisposables" should be disposed</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    You can't rely on garbage collection to clean up everything. Specifically, you can't count on
    it to release non-memory resources such as <code>File</code>s. For that, there's the <code>IDisposable</code>
    interface, and the contract that <code>Dispose</code> will always be called on such objects.
</p>
<p>
    When an <code>IDisposable</code> is a class member, then it's up to that class to call <code>Dispose</code>
    on it, ideally in its own <code>Dispose</code> method. If it's a local variable, then it should be instantiated
    with a <code>using</code> clause to prompt automatic cleanup when it goes out of scope.
</p>
<p>
    This rule raises issues on members that are never <code>Dispose</code>d.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class ResourceHolder
{
  private FileStream fs;  // Noncompliant; Dispose is never called
  public void OpenResource(string path)
  {
    this.fs = new FileStream(path, FileMode.Open);
  }
  public void CloseResource()
  {
    this.fs.Close();
  }
  public void WriteToFile(string path, string text)
  {
    var fs = new FileStream(path, FileMode.Open);  // Noncompliant
    var bytes = Encoding.UTF8.GetBytes(text);
    fs.Write(bytes, 0, bytes.Length);
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public class ResourceHolder : IDisposable
{
  private FileStream fs;
  public void OpenResource(string path)
  {
    this.fs = new FileStream(path, FileMode.Open);
  }
  public void CloseResource()
  {
    this.fs.Close();
  }

  public void Dispose()
  {
    this.fs.Dispose();
  }

  public void WriteToFile(string path, string text)
  {
    using (var fs = new FileStream(path, FileMode.Open))
    {
      var bytes = Encoding.UTF8.GetBytes(text);
      fs.Write(bytes, 0, bytes.Length);
    }
  }
}
</pre>

<h2>Exceptions</h2>
Local <code>IDisposable</code>s returned from methods are ignored, as are local <code>IDisposable</code>s that are
initialized with non-local <code>IDisposable</code>s.
<pre>
  public Stream WriteToFile(string path, string text)
  {
    var fs = new FileStream(path, FileMode.Open); // Compliant, because it is returned
    var bytes = Encoding.UTF8.GetBytes(text);
    fs.Write(bytes, 0, bytes.Length);
    return fs;
  }

  public void ReadFromStream(Stream s)
  {
    var sr = new StreamReader(s); // Compliant as it would close the underlying stream.
    // ...
  }
</pre>

<h2>See</h2>
<ul>
    <li> <a href="http://cwe.mitre.org/data/definitions/459.html">MITRE, CWE-459</a> - Incomplete Cleanup</li>
</ul>
]]></description>
    <tag>bug</tag>
    <tag>cwe</tag>
    <tag>denial-of-service</tag>
    <tag>security</tag>
  </rule>
  <rule>
    <key>S2997</key>
    <name>"IDisposables" created in a "using" statement should not be returned</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Typically you want to use <code>using</code> to create a local <code>IDisposable</code> variable; it will trigger
    disposal of the object when control passes out of the block's scope. The exception to this rule is when your
    method returns that <code>IDisposable</code>. In that case <code>using</code> disposes of the object before the
    caller can make use of it, likely causing exceptions at runtime. So you should either remove <code>using</code> or
    avoid returning the <code>IDisposable</code>.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public FileStream WriteToFile(string path, string text)
{
  using (var fs = File.Create(path)) // Noncompliant
  {
    var bytes = Encoding.UTF8.GetBytes(text);
    fs.Write(bytes, 0, bytes.Length);
    return fs;
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public FileStream WriteToFile(string path, string text)
{
  var fs = File.Create(path);
  var bytes = Encoding.UTF8.GetBytes(text);
  fs.Write(bytes, 0, bytes.Length);
  return fs;
}
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S2952</key>
    <name>Classes should "Dispose" of members from the classes' own "Dispose" methods</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    It is possible in an <code>IDisposable</code> to call <code>Dispose</code> on class members from any method, but the
    contract of <code>Dispose</code> is that it will clean up all unmanaged resources. Move disposing of members to some
    other method, and you risk resource leaks.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class ResourceHolder : IDisposable
{
  private FileStream fs;
  public void OpenResource(string path)
  {
    this.fs = new FileStream(path, FileMode.Open);
  }
  public void CloseResource()
  {
    this.fs.Close();
  }

  public void CleanUp()
  {
    this.fs.Dispose(); // Noncompliant; Dispose not called in class' Dispose method
  }

  public void Dispose()
  {
    // method added to satisfy demands of interface
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public class ResourceHolder : IDisposable
{
  private FileStream fs;
  public void OpenResource(string path)
  {
    this.fs = new FileStream(path, FileMode.Open);
  }
  public void CloseResource()
  {
    this.fs.Close();
  }

  public void Dispose()
  {
    this.fs.Dispose();
  }
}
</pre>

<h2>See</h2>
<ul>
    <li><a href="http://cwe.mitre.org/data/definitions/459.html">MITRE, CWE-459</a> - Incomplete Cleanup</li>
</ul>
]]></description>
    <tag>bug</tag>
    <tag>cwe</tag>
    <tag>denial-of-service</tag>
    <tag>security</tag>
  </rule>
  <rule>
    <key>S2953</key>
    <name>Methods named "Dispose" should implement "IDisposable.Dispose"</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    <code>Dispose</code> as a method name should be used exclusively to implement <code>IDisposable.Dispose</code> to prevent
    any confusion.
</p>
<p>
    It may be tempting to create a <code>Dispose</code> method for other purposes, but doing so will result in confusion and
    likely lead to problems in production.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class GarbageDisposal
{
  private int Dispose()  // Noncompliant
  {
    // ...
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public class GarbageDisposal : IDisposable
{
  public void Dispose()
  {
    // ...
  }
}
</pre>
or
<pre>
public class GarbageDisposal
{
  private int Grind()
  {
    // ...
  }
}
</pre>

<h2>Exceptions</h2>
<p>
    Methods named <code>Dispose</code> and invoked from the <code>IDisposable.Dispose</code> implementation are not reported.
</p>
<pre>
public class GarbageDisposal : IDisposable
{
  protected virtual void Dispose(bool disposing)
  {
    //...
  }
  public void Dispose()
  {
    Dispose(true);
    GC.SuppressFinalize(this);
  }
}
</pre>
]]></description>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S1186</key>
    <name>Methods should not be empty</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
There are several reasons for a method not to have a method body:
  <ul>
    <li>It is an unintentional omission, and should be fixed.</li>
    <li>It is not yet, or never will be, supported. In this case an <code>NotSupportedException</code> should be thrown.</li>
    <li>The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override.</li>
  </ul>
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public override void DoSomething()
{
}

public override void doSomethingElse()
{
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public override void DoSomething()
{
  // Do nothing because of X and Y.
}

public override void doSomethingElse()
{
  throw new NotSupportedException();
}
</pre>

<h2>Exceptions</h2>
<p>An abstract class' may have empty methods, in order to provide default implementations for child classes.</p>
<pre>
abstract class Animal
{
  public void Speak()
  {
  }
}
</pre>
]]></description>
    <tag>suspicious</tag>
  </rule>
  <rule>
    <key>S108</key>
    <name>Nested blocks of code should not be left empty</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
for (int i = 0; i < 42; i++) {}  // Empty on purpose or missing piece of code ?
</pre>

<h2>Exceptions</h2>
<p>
    When a block contains a comment, this block is not considered to be empty.
</p>
]]></description>
    <tag>suspicious</tag>
  </rule>
  <rule>
    <key>S2291</key>
    <name>Overflow checking should not be disabled for "Enumerable.Sum"</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    <code>Enumerable.Sum()</code> always executes addition in a <code>checked</code> context, so an
    <code>OverflowException</code> will be thrown if the value exceeds <code>MaxValue</code> even if an
    <code>unchecked</code> context was specified. Using an <code>unchecked</code> context anyway represents
    a misunderstanding of how <code>Sum</code> works.
</p>
<p>
    This rule raises an issue when an <code>unchecked</code> context is specified for a <code>Sum</code> on
    integer types.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
void Add(List&lt;int&gt; list)
{
  int d = unchecked(list.Sum());  // Noncompliant

  unchecked
  {
    int e = list.Sum();  // Noncompliant
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
void Add(List&lt;int&gt; list)
{
  int d = list.Sum();

  try
  {
    int e = list.Sum();
  }
  catch (System.OverflowException e)
  {
    // exception handling...
  }
}
</pre>

<h2>Exceptions</h2>
<p>
    When the <code>Sum()</code> call is inside a <code>try-catch</code> block, no issues are reported.
</p>

<pre>
void Add(List&lt;int&gt; list)
{
  unchecked
  {
    try
    {
      int e = list.Sum();
    }
    catch (System.OverflowException e)
    {
      // exception handling...
    }
  }
}
</pre>
]]></description>
    <tag>error-handling</tag>
    <tag>security</tag>
  </rule>
  <rule>
    <key>S1116</key>
    <name>Empty statements should be removed</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
  Empty statements, i.e. <code>;</code>, are usually introduced by mistake, for example because:
  <ul>
    <li>It was meant to be replaced by an actual statement, but this was forgotten.</li>
    <li>There was a typo which lead the semicolon to be doubled, i.e. <code>;;</code>.</li>
  </ul>
</p>

<h2>Noncompliant Code Example</h2>
<pre>
void doSomething()
{
  ; // Noncompliant - was used as a kind of TODO marker
}

void doSomethingElse()
{
  Console.WriteLine("Hello, world!");;  // Noncompliant - double ;
  ...
  // Rarely, they are used on purpose as the body of a loop. It is a bad practice to
  // have side-effects outside of the loop body
  for (int i = 0; i < 3; Console.WriteLine(i), i++); // Noncompliant
  ...
}
</pre>

<h2>Compliant Solution</h2>
<pre>
void doSomething()
{
}

void doSomethingElse()
{
  Console.WriteLine("Hello, world!");
  ...
  for (int i = 0; i < 3; i++)
  {
    Console.WriteLine(i);
   }
  ...
}
</pre>

<h2>See</h2>

<ul>
    <li>MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that the first character following the null statement is a white-space character.</li>
    <li>MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided that the first character following the null statement is a white-space character.</li>
    <li><a href="https://www.securecoding.cert.org/confluence/x/NYA5">CERT, MSC12-C</a> - Detect and remove code that has no effect</li>
    <li><a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP</a> - Detect and remove code that has no effect</li>
</ul>]]></description>
    <tag>cert</tag>
    <tag>misra</tag>
    <tag>unused</tag>
  </rule>
  <rule>
    <key>S2344</key>
    <name>Enumeration type names should not have "Flags" or "Enum" suffixes</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    The information that an enumeration type is actually an enumeration or a set of flags should not be duplicated in its name.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
enum FooFlags // Noncompliant
{
    Foo = 1
    Bar = 2
    Baz = 4
}
</pre>

<h2>Compliant Solution</h2>

<pre>
enum Foo
{
    Foo = 1
    Bar = 2
    Baz = 4
}
</pre>
]]></description>
    <tag>convention</tag>
  </rule>
  <rule>
    <key>S1244</key>
    <name>Floating point numbers should not be tested for equality</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Floating point math is imprecise because of the challenges of storing such values in a binary
    representation. Even worse, floating point math is not associative; push a <code>float</code> or a <code>double</code>
    through a series of simple mathematical operations and the answer will be different based on
    the order of those operation because of the rounding that takes place at each step.
</p>
<p>
    Even simple floating point assignments are not simple:
</p>
<pre>
float f = 0.1f; // 0.100000001490116119384765625
double d = 0.1; // 0.1000000000000000055511151231257827021181583404541015625
</pre>

<p>
    (Results will vary based on compiler and compiler settings)
</p>
<p>
    Therefore, the use of the equality (<code>==</code>) and inequality (<code>!=</code>) operators on
    <code>float</code> or <code>double</code> values is almost always an error.
</p>
<p>
    This rule checks for the use of direct and indirect equality/inequailty tests on floats and doubles.
</p>


<h2>Noncompliant Code Example</h2>
<pre>
float myNumber = 3.146f;
if ( myNumber == 3.146f ) //Noncompliant. Because of floating point imprecision, this will be false
{
  // ...
}

if (myNumber &lt;= 3.146f &amp;&amp; mNumber &gt;= 3.146f) // Noncompliant indirect equality test
{
  // ...
}

if (myNumber &lt; 4 || myNumber &gt; 4) // Noncompliant indirect inequality test
{
  // ...
}
</pre>

<h2>See</h2>
<ul>
    <li>MISRA C:2004, 13.3 - Floating-point expressions shall not be tested for equality or inequality.</li>
    <li>MISRA C++:2008, 6-2-2 - Floating-point expressions shall not be directly or indirectly tested for equality or inequality</li>
</ul>
]]></description>
    <tag>bug</tag>
    <tag>misra</tag>
  </rule>
  <rule>
    <key>S2197</key>
    <name>Modulus results should not be checked for direct equality</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    When the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the modulus
    of a variable for equality with a positive number (or a negative one) could result in unexpected results.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public boo IsOdd(int x)
{
  return x % 2 == 1;  // Noncompliant; if x is an odd negative, x % 2 == -1
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public bool IsOdd(int x)
{
  return x % 2 != 0;
}
</pre>
or
<pre>
public bool IsOdd(uint x)
{
  return x % 2 == 1;
}
</pre>
]]></description>
    <tag>suspicious</tag>
  </rule>
  <rule>
    <key>S1067</key>
    <name>Expressions should not be too complex</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
The complexity of an expression is defined by the number of <code>&&</code>, <code>||</code> and <code>condition ? ifTrue : ifFalse</code> operators it contains.<br/>
A single expression's complexity should not become too high to keep the code readable.
</p>

<h2>Noncompliant Code Example</h2>
<p>With the default threshold value 3</p>
<pre>
if (((condition1 && condition2) || (condition3 && condition4)) && condition5) { ... }
</pre>

<h2>Compliant Solution</h2>
<pre>
if ( (myFirstCondition() || mySecondCondition()) && myLastCondition()) { ... }
</pre>
]]></description>
    <tag>brain-overload</tag>
    <param>
      <key>max</key>
      <description><![CDATA[Maximum number of allowed conditional operators in an expression]]></description>
      <type>INTEGER</type>
      <defaultValue>3</defaultValue>
    </param>
  </rule>
  <rule>
    <key>S3052</key>
    <name>Fields should not be initialized to default values</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    The compiler automatically initializes class fields to their default values before setting them with any initialization
    values, so there is no need to explicitly set a field to its default value. Further, under the logic that cleaner code
    is better code, it's considered poor style to do so.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
class X
{
  public int field = 0; // Noncompliant; defaults to 0. Reinitializing incurs minor performance penalty
  public object o = null; //Noncompliant
}
</pre>

<h2>Compliant Solution</h2>
<pre>
class X
{
  public int field;
  public object o;
}
</pre>

<h2>Exceptions</h2>
<code>const</code> fields are ignored.
]]></description>
    <tag>convention</tag>
  </rule>
  <rule>
    <key>S2387</key>
    <name>Child class members should not shadow parent class members</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Having a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy
    and you'll get confusion at best, chaos at worst. Perhaps even worse is the case where a child class field varies from
    the name of a parent class only by case.
</p>
<p>
    This rule ignores <code>private</code> parent class members, but in all other such cases, the child class field should
    be renamed.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class Fruit
{
  protected Season ripe;
  protected Color flesh;

  // ...
}

public class Raspberry : Fruit
{
  private bool ripe;  // Noncompliant
  private static Color FLESH; // Noncompliant
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public class Fruit
{
  protected Season ripe;
  protected Color flesh;

  // ...
}

public class Raspberry : Fruit
{
  private bool ripened;
  private static Color FLESH_COLOR;
}
</pre>
]]></description>
    <tag>confusing</tag>
  </rule>
  <rule>
    <key>S2933</key>
    <name>Fields that are only assigned in the constructor should be "readonly"</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    <code>readonly</code> fields can only be assigned in a class constructor. If a class has a field that's
    not marked <code>readonly</code> but is only set in the constructor, it could cause confusion about the
    field's intended use. To avoid confusion, such fields should be marked <code>readonly</code> to make their
    intended use explicit, and to prevent future maintainers from inadvertently changing their use.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
class Person
{
  int _birthYear;  // Noncompliant
  Person(int birthYear)
  {
    _birthYear = birthYear;
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
class Person
{
  readonly int _birthYear;
  Person(int birthYear)
  {
    _birthYear = birthYear;
  }
}
</pre>
]]></description>
    <tag>confusing</tag>
  </rule>
  <rule>
    <key>S2357</key>
    <name>Fields should be private</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Fields should not be part of an API, and therefore should always be private. Indeed, they
    cannot be added to an interface for instance, and validation cannot be added later on without
    breaking backward compatiblity. Instead, developers should encapsulate their fields into
    properties. Explicit property getters and setters can be introduced for validation purposes
    or to smooth the transition to a newer system.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class Foo
{
  public int MagicNumber = 42;
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public class Foo
{
  public int MagicNumber
  {
    get { return 42; }
  }
}
</pre>
or
<pre>
public class Foo
{
  private int MagicNumber = 42;
}
</pre>

<h2>Exceptions</h2>
<p>
    <code>static</code> and <code>const</code> fields are ignored.
</p>
]]></description>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S104</key>
    <name>Files should not have too many lines</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
A source file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain.
Above a specific threshold, it is strongly advised to refactor it into smaller pieces of code which focus on well defined tasks.
Those smaller files will not only be easier to understand but also probably easier to test.
</p>
]]></description>
    <tag>brain-overload</tag>
    <param>
      <key>maximumFileLocThreshold</key>
      <description><![CDATA[Maximum authorized lines in a file.]]></description>
      <type>INTEGER</type>
      <defaultValue>1000</defaultValue>
    </param>
  </rule>
  <rule>
    <key>S2345</key>
    <name>Flags enumerations should explicitly initialize all their members</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Flags enumerations should not rely on the language to initialize the values of their members. Implicit initialization
    will set the first member to 0, and increment the value by one for each subsequent member. This implicit behavior does
    not allow members to be combined using the bitwise or operator.
</p>
<p>
    Instead, powers of two, i.e. 1, 2, 4, 8, 16, etc. should be used to explicitly initialize all the members.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
[Flags]
enum FruitType    // Non-Compliant
{
    Banana,
    Orange,
    Strawberry
}
class Program
{
    static void Main()
    {
        var bananaAndStrawberry = FruitType.Banana | FruitType.Strawberry;
        // Will display only Strawberry!
        Console.WriteLine(bananaAndStrawberry.ToString());
    }
}
</pre>

<h2>Compliant Solution</h2>

<pre>
[Flags]
enum FruitType    // Non-Compliant
{
    Banana = 1,
    Orange = 2,
    Strawberry = 4
}
class Program
{
    static void Main()
    {
        var bananaAndStrawberry = FruitType.Banana | FruitType.Strawberry;
        // Will display Banana and Strawberry, as expected.
        Console.WriteLine(bananaAndStrawberry.ToString());
    }
}
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S2346</key>
    <name>Flags enumerations zero-value members should be named "None"</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Consisitent use of "None" in flags enumerations indicates that all flag values are cleared.
    The value 0 should not be used to indicate any other state, since there is no way to check that the bit <code>0</code> is set.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
[Flags]
enum FruitType
{
    Void = 0,       // Non-Compliant
    Banana = 1,
    Orange = 2,
    Strawberry = 4
}
</pre>

<h2>Compliant Solution</h2>

<pre>
[Flags]
enum FruitType
{
    None = 0,       // Compliant
    Banana = 1,
    Orange = 2,
    Strawberry = 4
}
</pre>
]]></description>
    <tag>convention</tag>
  </rule>
  <rule>
    <key>S3376</key>
    <name>Attribute, EventArgs, and Exception type names should end with the type being extended</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Adherence to the standard naming conventions makes your code not only more readable, but more usable. For instance,
    <code>class FirstAttribute : Attribute</code> can be used simply with <code>First</code>, but you must use the full
    name for <code>class AttributeOne : Attribute</code>.
</p>
<p>
    This rule raises an issue when classes extending <code>Attribute</code>, <code>EventArgs</code>, or
    <code>Exception</code>, do not end with their parent class names.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
class AttributeOne : Attribute  // Noncompliant
{
}
</pre>

<h2>Compliant Solution</h2>
<pre>
class FirstAttribute : Attribute
{
}
</pre>

<h2>Exceptions</h2>
<p>
    If a class' direct base class doesn't follow the convention, then no issue is reported on the class itself, regardless of
    whether or not it conforms to the convention.
</p>
<pre>
class Timeout : Exception // Noncompliant
{
}
class ExtendedTimeout : Timeout // Ignored; doesn't conform to convention, but the direct base doesn't conform either
{
}
</pre>]]></description>
    <tag>convention</tag>
  </rule>
  <rule>
    <key>S3217</key>
    <name>"Explicit" conversions of "foreach" loops should not be used</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    The <code>foreach</code> statement was introduced in the C# language prior to generics. To make it easier to work with
    non-generic collections available at that time such as <code>ArrayList</code>, the <code>foreach</code> statements allows
    to downcast the collection's element of type <code>Object</code> into any other type. The problem is that, to achieve that,
    the <code>foreach</code> statements silently performs <code>explicit</code> type conversion, which at runtime can result in
    an <code>InvalidCastException</code> to be thrown.
</p>
<p>
    New C# code should use generics and not rely on <code>foreach</code> statement's silent <code>explicit</code> conversions.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
ArrayList list = new ArrayList();
list.Add(0);
list.Add(1);
// list.Add("surprise!"); // uncommenting this line will make both foreach below throw an InvalidCastException

foreach (object elementObject in list)
{
  int element = (int)elementObject; // This "explicit" conversion is hidden within the foreach loop
  Console.WriteLine(element);
}

// can be written in an equivalent but shorter way:

foreach (int element in list) // Noncompliant
{
  Console.WriteLine(element);
}
</pre>

<h2>Compliant Solution</h2>
<pre>
List&lt;int&gt; list = new List&lt;int&gt;();
list.Add(0);
list.Add(1);
// list.Add("surprise!"); // uncommenting this line won't compile

foreach (int element in list)
{
  Console.WriteLine(element);
}
</pre>
or
<pre>
ArrayList list = new ArrayList();
list.Add(0);
list.Add(1);
list.Add("surprise!");

foreach (int element in list.OfType&lt;int&gt;())
{
  Console.WriteLine(element);
}
</pre>
]]></description>
    <tag>suspicious</tag>
  </rule>
  <rule>
    <key>S127</key>
    <name>"for" loop stop conditions should be invariant</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    <code>for</code> loop stop conditions must be invariant (i.e. true at both the beginning and ending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins.
</p>
<p>
    Stop conditions that are not invariant are difficult to understand and maintain, and will likely lead to the introduction of errors in the future.
</p>
<p>
    This rule tracks three types of non-invariant stop conditions:
    <ul>
        <li>When the loop counters are updated in the body of the <code>for</code> loop</li>
        <li>When the stop condition depend upon a method call</li>
        <li>When the stop condition depends on an object property, since such properties could change during the execution of the loop.</li>
    </ul>
</p>

<h2>Noncompliant Code Example</h2>
<pre>
class Foo
{
    static void Main()
    {
        for (int i = 1; i &lt;= 5; i++)
        {
            Console.WriteLine(i);
            if (condition)
            {
               i = 20;
           }
        }
    }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
class Foo
{
    static void Main()
    {
        for (int i = 1; i &lt;= 5; i++)
        {
            Console.WriteLine(i);
        }
    }
}
</pre>

<h2>See</h2>

<ul>
    <li>MISRA C:2004, 13.6 - Numeric variables being used within a for loop for iteration counting shall not be modified in the body of the loop.</li>
    <li>MISRA C++:2008, 6-5-3 - The loop-counter shall not be modified within condition or statement.</li>
</ul>
]]></description>
    <tag>misra</tag>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S1994</key>
    <name>"for" loop incrementers should modify the variable being tested in the loop's stop condition</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
It is almost always an error when a <code>for</code> loop's stop condition and incrementer don't act on the same variable. Even when it is not, it could confuse future maintainers of the code, and should be avoided.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
for (i = 0; i < 10; j++) // Noncompliant
{
  // ...
}
</pre>

<h2>Compliant Solution</h2>
<pre>
for (i = 0; i < 10; i++)
{
  // ...
}
</pre>]]></description>
    <tag>suspicious</tag>
  </rule>
  <rule>
    <key>S1541</key>
    <name>Methods should not be too complex</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>The cyclomatic complexity of a function should not exceed a defined threshold.</p>
<p>Complex code can perform poorly and will in any case be difficult to understand and therefore to maintain.</p>
]]></description>
    <tag>brain-overload</tag>
    <param>
      <key>maximumFunctionComplexityThreshold</key>
      <description><![CDATA[The maximum authorized complexity in function]]></description>
      <type>INTEGER</type>
      <defaultValue>10</defaultValue>
    </param>
  </rule>
  <rule>
    <key>S2934</key>
    <name>Property assignments should not be made for "readonly" fields not constrained to reference types</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    While the properties of a <code>readonly</code> reference type field can still be changed after initialization,
    those of a <code>readonly</code> value field, such as a <code>struct</code>, cannot.
</p>
<p>
    If the member could be either a <code>class</code> or a <code>struct</code> then assignment to its properties
    could be unreliable, working sometimes but not others.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
interface IPoint
{
  int X { get; set; }
  int Y { get; set; }
}

class PointManager&lt;T&gt; where T: IPoint
{
  readonly T point;  // this could be a struct
  public PointManager(T point)
  {
    this.point = point;
  }

  public void MovePointVertically(int newX)
  {
    point.X = newX; //Noncompliant; if point is a struct, then nothing happened
    Console.WriteLine(point.X);
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
interface IPoint
{
  int X { get; set; }
  int Y { get; set; }
}

class PointManager&lt;T&gt; where T : IPoint
{
  readonly T point;  // this could be a struct
  public PointManager(T point)
  {
    this.point = point;
  }

  public void MovePointVertically(int newX) // assignment has been removed
  {
    Console.WriteLine(point.X);
  }
}
</pre>
or
<pre>
interface IPoint
{
  int X { get; set; }
  int Y { get; set; }
}

class PointManager&lt;T&gt; where T : class, IPoint
{
  readonly T point;  // this can only be a class
  public PointManager(T point)
  {
    this.point = point;
  }

  public void MovePointVertically(int newX)
  {
    point.X = newX;  // this assignment is guaranteed to work
    Console.WriteLine(point.X);
  }
}
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S2955</key>
    <name>Generic parameters not constrained to reference types should not be compared to "null"</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    When constraints have not been applied to restrict a generic type parameter to be a reference type,
    then a value type, such as a <code>struct</code>, could also be passed. In such cases, comparing the
    type parameter to <code>null</code> would always be false, because a <code>struct</code> can
    be empty, but never <code>null</code>. If a value type is truly what's expected, then the comparison should use
    <code>default()</code>. If it's not, then constraints should be added so that no value type can be
    passed.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
private bool IsDefault&lt;T&gt;(T value)
{
  if (value == null) // Noncompliant
  {
    // ...
  }
  // ...
}
</pre>

<h2>Compliant Solution</h2>
<pre>
private bool IsDefault&lt;T&gt;(T value)
{
  if(object.Equals(value, default(T)))
  {
    // ...
  }
  // ...
}
</pre>
or
<pre>
private bool IsDefault&lt;T&gt;(T value) where T : class
{
  if (value == null)
  {
    // ...
  }
  // ...
}
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S3246</key>
    <name>Generic type parameters should be co/contravariant when possible</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    In the interests of making code as usable as possible, interfaces and delegates with generic parameters should use the
    <code>out</code> and <code>in</code> modifiers when possible to make the interfaces and delegates covariant and contravariant,
    respectively.
</p>
<p>
    The <code>out</code> keyword can be used when the type parameter is used only as a return type in the interface or delegate.
    Doing so makes the parameter covariant, and allows interface and delegate instances created with a sub-type to be used as
    instances created with a base type. The most notable example of this is <code>IEnumerable&lt;out T&gt;</code>, which allows
    the assignment of an <code>IEnumerable&lt;string&gt;</code> instance to an <code>IEnumerable&lt;object&gt;</code> variable,
    for instance.
</p>
<p>
    The <code>in</code> keyword can be used when the type parameter is used only as a method parameter in the interface or a
    parameter in the delegate. Doing so makes the parameter contravariant, and allows interface and delegate instances created
    with a base type to be used as instances created with a sub-type. I.e. this is the inversion of covariance. The most notable
    example of this is the <code>Action&lt;in T&gt;</code> delegate, which allows the assignment of an
    <code>Action&lt;object&gt;</code> instance to a <code>Action&lt;string&gt;</code> variable, for instance.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
interface IConsumer&lt;T&gt;  // Noncompliant
{
    bool Eat(T fruit);
}
</pre>

<h2>Compliant Solution</h2>
<pre>
interface IConsumer&lt;in T&gt;
{
    bool Eat(T fruit);
}
</pre>
]]></description>
    <tag>api-design</tag>
  </rule>
  <rule>
    <key>S2326</key>
    <name>Unused type parameters should be removed</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Type parameters that aren't used are dead code, which can only distract and possibly confuse
    developers during maintenance. Therefore, unused type parameters should be removed.
</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class MoreMath&lt;T&gt; // Noncompliant; &lt;T&gt;is ignored
{
  public int Add&lt;T&gt;(int a, int b) // Noncompliant; &lt;T&gt; is ignored
  {
    return a + b;
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public class MoreMath
{
  public int Add (int a, int b)
  {
    return a + b;
  }
}
</pre>
]]></description>
    <tag>unused</tag>
  </rule>
  <rule>
    <key>S3397</key>
    <name>"base.Equals" should not be used to check for reference equality in "Equals" if "base" is not "object"</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    <code>object.Equals()</code> overrides can be optimized by checking first for reference equality between <code>this</code> and the
    parameter. This check can be implemented by calling <code>object.ReferenceEquals()</code> or <code>base.Equals()</code>, where
    <code>base</code> is <code>object</code>. However, using <code>base.Equals()</code> is a maintenance hazard because while it works
    if you extend <code>Object</code> directly, if you introduce a new base class that overrides <code>Equals</code>, it suddenly stops
    working.
</p>
<p>
    This rule raises an issue if <code>base.Equals()</code> is used but <code>base</code> is not <code>object</code>.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
class Base
{
  private int baseField;

  public override bool Equals(object other)
  {
    if (base.Equals(other)) // Okay; base is object
    {
      return true;
    }

    return this.baseField == ((Base)other).baseField;
  }
}

class Derived : Base
{
  private int derivedField;

  public override bool Equals(object other)
  {
    if (base.Equals(other))  // Noncompliant
    {
      return true;
    }

    return this.derivedField == ((Derived)other).derivedField;
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
class Base
{
  private int baseField;

  public override bool Equals(object other)
  {
    if (object.ReferenceEquals(this, other))  // base.Equals is okay here, but object.ReferenceEquals is better
    {
      return true;
    }

    return this.baseField == ((Base)other).baseField;
  }
}

class Derived : Base
{
  private int derivedField;

  public override bool Equals(object other)
  {
    if (object.ReferenceEquals(this, other))
    {
      return true;
    }

    return base.Equals(other) &amp;&amp; this.derivedField == ((Derived)other).derivedField;
  }
}
</pre>]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S3249</key>
    <name>Classes directly extending "Object" should not call "base" in "GetHashCode" or "Equals"</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Making a <code>base</code> call in an overridden method is generally a good idea, but not in <code>GetHashCode</code> and
    <code>Equals</code> for classes that directly extend <code>Object</code> because those methods are based on the object reference.
    Meaning that no two <code>Objects</code> that use those <code>base</code> methods will ever be equal or have the same hash.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class Point
{
  private readonly int x;
  public MyClass(int x)
  {
    this.x = x;
  }
  public override int GetHashCode()
  {
    return x.GetHashCode() ^ base.GetHashCode(); //Noncompliant
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public class Point
{
  private readonly int x;
  public MyClass(int x)
  {
    this.x = x;
  }
  public override int GetHashCode()
  {
    return x.GetHashCode();
  }
}
</pre>

<h2>Exceptions</h2>
<p>
    This rule doesn't report on guard conditions checking for reference equality.
</p>
<pre>
public class Point
{
  public override bool Equals(object obj)
  {
    if (base.Equals(obj)) // Compliant, although it could be replaced with object.ReferenceEquals(obj, this), which is clearer
    {
      return true;
    }
    ...
  }
}
</pre>

]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S2328</key>
    <name>"GetHashCode" should not reference mutable fields</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    <code>GetHashCode</code> is used to file an object in a <code>Dictionary</code> or <code>Hashtable</code>.
    If <code>GetHashCode</code> uses non-<code>readonly</code> fields and those fields change after the object
    is stored, the object immediately becomes mis-filed in the <code>Hashtable</code>. Any subsequent test to
    see if the object is in the <code>Hashtable</code> will return a false negative.
</p>
<h2>Noncompliant Code Example</h2>
<pre>
public class Person
{
  public int age;
  public string name;

  public override int GetHashCode()
  {
    int hash = 12;
    hash += this.age.GetHashCode(); // Noncompliant
    hash += this.name.GetHashCode(); // Noncompliant
    return hash;
  }
</pre>

<h2>Compliant Solution</h2>
<pre>
public class Person
{
  public readonly DateTime birthday;
  public string name;

  public override int GetHashCode()
  {
    int hash = 12;
    hash += this.birthday.GetHashCode();
    return hash;
  }
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S2219</key>
    <name>"Type.IsAssignableFrom()" should not be used to check object type</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    To check the type of an object there are at least three options:
    <ul>
        <li>The simplest and shortest one uses the <code>expr is SomeType</code> operator</li>
        <li>The slightly longer <code>typeInstance.IsInstanceOfType(expr)</code></li>
        <li>The cumbersome and error-prone one uses <code>expr1.GetType().IsAssignableFrom(expr2.GetType())</code></li>
    </ul>
</p>

<h2>Noncompliant Code Example</h2>
<pre>
A expr1;
B expr2;
if (expr2.GetType().IsAssignableFrom(expr1.GetType())) { /* ... */ } // Noncompliant
</pre>

<h2>Compliant Solution</h2>
<pre>
A expr;
if (expr is MyType) { /* ... */ }
</pre>

or, when the type is not known at compile time:

<pre>
A expr;
Type myType;
if (myType.IsInstanceOfType(expr)) { /* ... */ }
</pre>]]></description>
    <tag>clumsy</tag>
  </rule>
  <rule>
    <key>S907</key>
    <name>"goto" statement should not be used</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    <code>goto</code> is an unstructured control flow statement. It makes code less readable and maintainable.
    Structured control flow statements such as <code>if</code>, <code>for</code>, <code>while</code>,
    <code>continue</code> or <code>break</code> should be used instead.
</p>

<h2>See</h2>

<ul>
    <li>MISRA C:2004, 14.4 - The goto statement shall not be used.</li>
    <li>MISRA C:2012, 15.1 - The goto statement should not be used</li>
</ul>
]]></description>
    <tag>brain-overload</tag>
    <tag>misra</tag>
  </rule>
  <rule>
    <key>S1313</key>
    <name>IP addresses should not be hardcoded</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Hardcoding an IP address into source code is a bad idea for several reasons:
    <ul>
        <li>
            a recompile is required if the address changes
        </li>
        <li>
            it forces the same address to be used in every environment (dev, sys, qa, prod)
        </li>
        <li>
            it places the responsibility of setting the value to use in production on the shoulders of the developer
        </li>
        <li>
            it allows attackers to decompile the code and thereby discover a potentially sensitive address
        </li>
    </ul>
</p>

<h2>Noncompliant Code Example</h2>
<pre>
var ip = "127.0.0.1";
var address = IPAddress.Parse(ip);
</pre>

<h2>Compliant Solution</h2>
<pre>
var ip = ConfigurationManager.AppSettings["myapplication.ip"];
var address = IPAddress.Parse(ip);
</pre>

<h2>Exceptions</h2>
<p>
    Although "::" is a valid IPv6 address, the rule doesn't report on it.
</p>

<h2>See</h2>

<ul>
    <li> <a href="https://www.securecoding.cert.org/confluence/x/qQCHAQ">CERT, MSC03-J</a> - Never hard code sensitive information</li>
</ul>]]></description>
    <tag>cert</tag>
    <tag>security</tag>
  </rule>
  <rule>
    <key>S126</key>
    <name>"if ... else if" constructs should end with "else" clause</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
  This rule applies whenever an <code>if</code> statement is followed by one or
  more <code>else if</code> statements, the final <code>else if</code> should be
  followed by an <code>else</code> statement.
</p>

<p>
The requirement for a final <code>else</code> statement is defensive programming.
The <code>else</code> statement should either take appropriate action or contain
a suitable comment as to why no action is taken. This is consistent with the
requirement to have a final <code>default</code> clause in a <code>switch</code>
statement.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
if (x == 0)
{
  doSomething();
} else if (x == 1)
{
  doSomethingElse();
}
</pre>

<h2>Compliant Solution</h2>
<pre>
if (x == 0)
{
  doSomething();
} else if (x == 1)
{
  doSomethingElse();
} else
{
  throw new IllegalStateException();
}
</pre>

<h2>See</h2>

<ul>
    <li>MISRA C:2004, 14.10 - All if...else if constructs shall be terminated with an else clause.</li>
    <li>MISRA C++:2008, 6-4-2 - All if...else if constructs shall be terminated with an else clause.</li>
    <li>MISRA C:2012, 15.7 - All if...else if constructs shall be terminated with an else statement</li>
    <li><a href="https://www.securecoding.cert.org/confluence/x/YgE">CERT, MSC01-C</a> - Strive for logical completeness</li>
    <li><a href="https://www.securecoding.cert.org/confluence/x/JoIyAQ">CERT, MSC01-CPP</a> - Strive for logical completeness</li>
    <li><a href="https://www.securecoding.cert.org/confluence/x/PQHRAw">CERT, MSC64-Java</a> - Strive for logical completeness</li>
</ul>
]]></description>
    <tag>cert</tag>
    <tag>misra</tag>
  </rule>
  <rule>
    <key>S1066</key>
    <name>Collapsible "if" statements should be merged</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Merging collapsible <code>if</code> statements increases the code's readability.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
if (condition1)
{
  if (condition2)
  {
    ...
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
if (condition1 &amp;&amp; condition2)
{
  ...
}
</pre>
]]></description>
    <tag>clumsy</tag>
  </rule>
  <rule>
    <key>S1145</key>
    <name>Useless "if(true) {...}" and "if(false){...}" blocks should be removed</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
  <code>if</code> statements with conditions that are always false have the effect of making blocks of code non-functional. This can be useful during debugging, but should not be checked in. <code>if</code> statements with conditions that are always true are completely redundant, and make the code less readable.
</p>
<p>
In either case, unconditional <code>if</code> statements should be removed.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
if (true)
{
  doSomething();
}
...
if (false)
{
  doSomethingElse();
}
</pre>

<h2>Compliant Solution</h2>
<pre>
doSomething();
...
</pre>
]]></description>
    <tag>bug</tag>
    <tag>cwe</tag>
    <tag>misra</tag>
    <tag>security</tag>
  </rule>
  <rule>
    <key>S2692</key>
    <name>"IndexOf" checks should not be for positive numbers</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Most checks against an <code>IndexOf</code> value compare it with -1 because 0 is a valid index. Any checks which look for
    values <code>&gt;0</code> ignore the first element, which is likely a bug. If the intent is merely to check inclusion of a
    value in a <code>string</code>, <code>List</code>, or an array, consider using the <code>Contains</code> method instead.
</p>
<p>
    This rule raises an issue when an <code>IndexOf</code> value retrieved from a <code>string</code>, <code>List</code>,
    or array is tested against <code>&gt;0</code>.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
string color = "blue";
string name = "ishmael";

List&lt;string&gt; strings = new List&lt;string&gt; ();
strings.add(color);
strings.add(name);
string[] stringArray = strings.ToArray();

if (strings.IndexOf(color) &gt; 0) // Noncompliant
{
  // ...
}
if (name.IndexOf("ish") &gt; 0) // Noncompliant
{
  // ...
}
if (name.IndexOf("ae") &gt; 0) // Noncompliant
{
  // ...
}
if (Array.IndexOf(stringArray, color) &gt; 0) // Noncompliant
{
  // ...
}
</pre>

<h2>Compliant Solution</h2>
<pre>
string color = "blue";
string name = "ishmael";
List&lt;string&gt; strings = new List&lt;string&gt; ();
strings.add(color);
strings.add(name);
string[] stringArray = strings.ToArray();
if (strings.IndexOf(color) &gt; -1)
{
  // ...
}
if (name.IndexOf("ish") &gt;= 0)
{
  // ...
}
if (name.Contains("ae")
{
  // ...
}
if (Array.IndexOf(stringArray, color) &gt;= 0)
{
  // ...
}
</pre>
]]></description>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S2278</key>
    <name>Neither DES (Data Encryption Standard) nor DESede (3DES) should be used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    According to the US National Institute of Standards and Technology (NIST), the Data Encryption Standard (DES) is no longer
    considered secure:
</p>
<blockquote>
    <p>
        Adopted in 1977 for federal agencies to use in protecting sensitive, unclassified information, the DES is being withdrawn
        because it no longer provides the security that is needed to protect federal government information.
    </p>
    <p>
        Federal agencies are encouraged to use the Advanced Encryption Standard, a faster and stronger algorithm approved as FIPS
        197 in 2001.
    </p>
</blockquote>

<h2>Noncompliant Code Example</h2>
<pre>
using (var tripleDES = new TripleDESCryptoServiceProvider()) //Noncompliant
{
  //...
}
</pre>

<h2>Compliant Solution</h2>
<pre>
using (var aes = new AesCryptoServiceProvider())
{
  //...
}
</pre>

<h2>See</h2>

<ul>
    <li><a href="http://cwe.mitre.org/data/definitions/326.html">MITRE CWE-326</a> - Inadequate Encryption Strength</li>
    <li><a href="http://cwe.mitre.org/data/definitions/327.html">MITRE CWE-327</a> - Use of a Broken or Risky Cryptographic Algorithm</li>
    <li><a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure">OWASP Top Ten 2013 Category A6</a> - Sensitive Data Exposure</li>
    <li>Derived from FindSecBugs rule <a href="http://h3xstream.github.io/find-sec-bugs/bugs.htm#DES_USAGE">DES / DESede Unsafe</a></li>
</ul>]]></description>
    <tag>cwe</tag>
    <tag>owasp-a6</tag>
    <tag>security</tag>
  </rule>
  <rule>
    <key>S2070</key>
    <name>SHA-1 and Message-Digest hash algorithms should not be used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    The MD5 algorithm and its successor, SHA-1, are no longer considered secure, because it is too easy to
    create hash collisions with them. That is, it takes too little computational effort to come up with a
    different input that produces the same MD5 or SHA-1 hash, and using the new, same-hash value gives an
    attacker the same access as if he had the originally-hashed value. This applies as well to the other
    Message-Digest algorithms: MD2, MD4, MD6.
</p>

<p>
    This rule tracks usage of the <code>System.Security.Cryptography.CryptoConfig.CreateFromName()</code>, and <code>System.Security.Cryptography.HashAlgorithm.Create()</code> methods to instantiate MD5 or SHA-1 algorithms, and of derived class instances of <code>System.Security.Cryptography.SHA1</code> and <code>System.Security.Cryptography.MD5</code>.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
var hashProvider1 = new MD5CryptoServiceProvider(); //Noncompliant
var hashProvider2 = (HashAlgorithm)CryptoConfig.CreateFromName("MD5"); //Noncompliant
var hashProvider3 = new SHA1Managed(); //Noncompliant
var hashProvider4 = HashAlgorithm.Create("SHA1"); //Noncompliant
</pre>

<h2>Compliant Solution</h2>
<pre>
var hashProvider1 = new SHA256Managed();
var hashProvider2 = (HashAlgorithm)CryptoConfig.CreateFromName("SHA256Managed");
var hashProvider3 = HashAlgorithm.Create("SHA256Managed");
</pre>

<h2>See</h2>

<ul>
    <li> <a href="http://cwe.mitre.org/data/definitions/328">MITRE, CWE-328</a> - Reversible One-Way Hash</li>
    <li> <a href="http://cwe.mitre.org/data/definitions/327">MITRE, CWE-327</a> - Use of a Broken or Risky Cryptographic Algorithm</li>
    <li> <a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure">OWASP Top Ten 2013 Category A6</a> - Sensitive Data Exposure</li>
    <li> <a href="http://www.sans.org/top25-software-errors/">SANS Top 25</a> - Porous Defenses</li>
    <li>Derived from FindSecBugs rule <a href="http://h3xstream.github.io/find-sec-bugs/bugs.htm#WEAK_MESSAGE_DIGEST">MessageDigest Is Weak</a></li>
</ul>]]></description>
    <tag>cwe</tag>
    <tag>owasp-a6</tag>
    <tag>sans-top25-porous</tag>
    <tag>security</tag>
  </rule>
  <rule>
    <key>S103</key>
    <name>Lines should not be too long</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.
</p>
]]></description>
    <tag>convention</tag>
    <param>
      <key>maximumLineLength</key>
      <description><![CDATA[The maximum authorized line length.]]></description>
      <type>INTEGER</type>
      <defaultValue>200</defaultValue>
    </param>
  </rule>
  <rule>
    <key>S818</key>
    <name>Literal suffixes should be upper case</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Using upper case literal suffixes removes the potential ambiguity between "1" (digit 1) and "l" (letter el) for declaring literals.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
const uint a = 0u;      // Noncompliant
const long b = 0l;      // Noncompliant
const ulong c = 0Ul;     // Noncompliant
const ulong d = 0uL;     // Noncompliant
const decimal e = 1.2m;  // Noncompliant
const float f = 1.2f;    // Noncompliant
const double g = 1.2d;    // Noncompliant
</pre>

<h2>Compliant Solution</h2>
<pre>
const uint a = 0U;
const long b = 0L;
const ulong c = 0UL;
const ulong d = 0UL;
const decimal e = 1.2M;
const float f = 1.2F;
const double g = 1.2D;
</pre>

<h2>See</h2>
<ul>
    <li>MISRA C++:2008, 2-13-4 - Literal suffixes shall be upper case</li>
    <li>MISRA C:2012, 7.3 - The lowercase character "l" shall not be used in a literal suffix</li>
    <li><a href="https://www.securecoding.cert.org/confluence/x/koAtAQ">CERT DCL16-C</a> - Use "L," not "l," to indicate a long value</li>
    <li><a href="https://www.securecoding.cert.org/confluence/x/n4AtAQ">CERT DCL16-CPP</a> - Use "L," not "l," to indicate a long value</li>
</ul>
]]></description>
    <tag>cert</tag>
    <tag>convention</tag>
    <tag>misra</tag>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S2551</key>
    <name>Types and "this" should not be used for locking</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Locking on the current object instance (i.e. <code>this</code>), or on a <code>Type</code> object increases the chance
    of deadlocks because any other thread could acquire (or attempt to acquire) the same lock for another unrelated purpose.
</p>
<p>
    Instead, a new, private <code>object</code> should be created and used for the lock.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public void MyLockingMethod()
{
  lock (this) // Noncompliant
  {
    // ...
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
object lockObj = new object();

public void MyLockingMethod()
{
  lock (lockObj)
  {
    // ...
  }
}
</pre>
]]></description>
    <tag>bug</tag>
    <tag>multi-threading</tag>
  </rule>
  <rule>
    <key>S3218</key>
    <name>Inner class members should not shadow outer class "static" or type members</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    It's possible to name the members of an inner class the same as the <code>static</code> members of its enclosing class -
    possible, but a bad idea. That's because maintainers may be confused about which members are being used where. Instead the
    inner class' members should be renamed and all the references updated.
</p>

<h2>Noncompliant Code Sample</h2>
<pre>
class Outer
{
  public static int A;

  public class Inner
  {
    public int A; //Noncompliant
    public int MyProp
    {
      get { return A; }  // Returns inner A. Was that intended?
    }
  }
}
</pre>
After a rename
<pre>
class Outer
{
  public static int A;

  public class Inner
  {
    public int B;
    public int MyProp
    {
      get { return A; }  // Still compiles and runs but functionality has changed
    }
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
class Outer
{
  public static int A;

  public class Inner
  {
    public int InnerA;
    public int MyProp
    {
      get { return InnerA; }
    }
  }
}
</pre>]]></description>
    <tag>design</tag>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S100</key>
    <name>Method name should comply with a naming convention</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Shared naming conventions allow teams to collaborate efficiently. This rule checks that all method names match a provided
    regular expression.
</p>

<p>The following code:</p>

<h2>Noncompliant Code Example</h2>
<p>With default provided regular expression <code>^[A-Z][a-zA-Z0-9_]*[a-zA-Z0-9]$</code>:</p>
<pre>
public int doSomething(){...}
</pre>

<p>should be refactored into:</p>

<pre>
public int DoSomething(){...}
</pre>
]]></description>
    <tag>convention</tag>
    <param>
      <key>format</key>
      <description><![CDATA[Regular expression used to check the method names against]]></description>
      <type>STRING</type>
      <defaultValue>^[A-Z][a-zA-Z0-9_]*[a-zA-Z0-9]$</defaultValue>
    </param>
  </rule>
  <rule>
    <key>S3427</key>
    <name>Method overloads with default parameter values should not overlap</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    The rules for method resolution are complex and perhaps not properly understood by all coders. Having overloads with
    optional parameter values make the matter even harder to understand. An overload with default parameter values can be
    hidden by one without the optional parameters.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class MyClass
{
  void Print(string[] messages) {...}
  void Print(string[] messages, string delimiter = "\n") {...} // Noncompliant; default parameter value is hidden by overload
}

// ...
MyClass myClass = new MyClass();

myClass.Print(new string[3] {"yes", "no", "maybe"});  // which version of Print will be called?
</pre>]]></description>
    <tag>pitfall</tag>
    <tag>unused</tag>
  </rule>
  <rule>
    <key>S3262</key>
    <name>"params" should be used on overrides</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Overriding methods automatically inherit the <code>params</code> behavior. To ease readability, this modifier should be explicitly used in
    the overriding method as well.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
class Base
{
  public virtual void Method(params int[] numbers)
  {
    ...
  }
}
class Derived : Base
{
  public override void Method(int[] numbers) // Noncompliant, the params is missing.
  {
    ...
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
class Base
{
  public virtual void Method(params int[] numbers)
  {
    ...
  }
}
class Derived : Base
{
  public override void Method(params int[] numbers)
  {
    ...
  }
}
</pre>
]]></description>
    <tag>confusing</tag>
  </rule>
  <rule>
    <key>S1172</key>
    <name>Unused method parameters should be removed</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Unused parameters are misleading. Whatever the value passed to such parameters is, the behavior will be the same.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
void DoSomething(int a, int b) // "b" is unused
{
  Compute(a);
}
</pre>

<h2>Compliant Solution</h2>
<pre>
void DoSomething(int a)
{
  Compute(a);
}
</pre>

<h2>Exceptions</h2>
<p>
    <code>virtual</code>, <code>override</code> methods and interface implementations are ignored.
</p>
<pre>
override void DoSomething(int a, int b) // no issue reported on b
{
  Compute(a);
}
</pre>

<p>
    Furthermore, the <code>this</code> parameter of extension methods is also ignored.
</p>
<pre>
public static class Extensions
{
  public static void MyHelper(this HtmlHelper helper) //no issue reported here
  {
    // no use of helper here
  }
}
</pre>

<h2>See</h2>

<ul>
    <li>MISRA C++:2008, 0-1-11</li>
    <li>MISRA C:2012, 2.7</li>
</ul>
]]></description>
    <tag>misra</tag>
    <tag>unused</tag>
  </rule>
  <rule>
    <key>S2681</key>
    <name>Multiline blocks should be enclosed in curly braces</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
Curly braces can be omitted from a one-line block, such as with an <code>if</code> statement or <code>for</code> loop, but doing so can be misleading and induce bugs.
This rule raises an issue when the indentation of the lines after a one-line block indicates an intent to include those lines in the block, but the omission of curly braces means the lines will be unconditionally executed once.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
if (condition)
  firstActionInBlock();
  secondAction();  // Noncompliant; executed unconditionally
thirdAction();

string str = null;
for (int i = 0; i < array.length; i++)
  str = array[i];
  doTheThing(str);  // Noncompliant; executed only on last array element
</pre>

<h2>Compliant Solution</h2>
<pre>
if (condition)
{
  firstActionInBlock();
  secondAction();
}
thirdAction();

string str = null;
for (int i = 0; i < array.length; i++)
{
  str = array[i];
  doTheThing(str);
}
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S1659</key>
    <name>Multiple variables should not be declared on the same line</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Declaring multiple variable on one line is difficult to read.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
class MyClass
{
  private int a, b; // Noncompliant

  public void Method()
  {
    int c, d; // Noncompliant
  }
}
</pre>

<h2>Compliant Solution</h2>

<pre>
class MyClass
{
  private int a;
  private int b;

  public void Method()
  {
    int c;
    int d;
  }
}
</pre>
]]></description>
    <tag>convention</tag>
  </rule>
  <rule>
    <key>S1848</key>
    <name>Objects should not be created to be dropped immediately without being used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could lead to an unexpected behavior in production.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
if (x < 0)
  new ArgumentException("x must be nonnegative");
</pre>

<h2>Compliant Solution</h2>
<pre>
if (x < 0)
  throw new ArgumentException("x must be nonnegative");
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S2360</key>
    <name>Optional parameters should not be used</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    The overloading mechanism should be used in place of optional parameters for several reasons:
    <ul>
        <li>Optional parameter values are baked into the method call site code, thus, if a default value has been changed, all referencing assemblies need to be rebuilt, otherwise the original values will be used.</li>
        <li>The Common Language Specification (CLS) allows compilers to ignore default parameter values, and thus require the caller to explicitly specify the values.</li>
        <li>The concept of optional argument exists only in VB.Net and C#. In all other languages like C++ or Java, the overloading mechanism is the only way to get the same behavior.</li>
        <li>Optional parameters prevent muddying the definition of the function contract. Here is a simple example: if there are two optional parameters, when one is defined, is the second one still optional or mandatory?</li>
    </ul>
</p>

<h2>Noncompliant Code Example</h2>
<pre>
void Notify(string company, string office = "QJZ") // Noncompliant
{
}
</pre>

<h2>Compliant Solution</h2>

<pre>
void Notify(string company)
{
  Notify(company, "QJZ");
}
void Notify(string company, string office = "QJZ")
{
}
</pre>
]]></description>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S3220</key>
    <name>Method calls should not resolve ambiguously to overloads with "params"</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    The rules for method resolution are complex and perhaps not properly understood by all coders. The <code>params</code> keyword can make
    method declarations overlap in non-obvious ways, so that slight changes in the argument types of an invocation can resolve to different
    methods.
</p>
<p>
    This rule raises an issue when an invocation resolves to a method declaration with <code>params</code>, but could also resolve to another
    non-<code>params</code> method too.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class MyClass
{
  private void Format(string a, params object[] b) { }

  private void Format(object a, object b, object c) { }
}

// ...
MyClass myClass = new MyClass();

myClass.Format("", null, null); //Noncompliant, resolves to the first Format with params, but was that intended?
</pre>
]]></description>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S3169</key>
    <name>Multiple "OrderBy" calls should not be used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    There's no point in chaining multiple <code>OrderBy</code> calls in a LINQ; only the last one will be reflected in the result
    because each subsequent call completely reorders the list. Thus, calling <code>OrderBy</code> multiple times is a performance
    issue as well, because all of the sorting will be executed, but only the result of the last sort will be kept.
</p>
<p>
    Instead, use <code>ThenBy</code> for each call after the first.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
var x = personList
  .OrderBy(person => person.Age)
  .OrderBy(person => person.Name)  // Noncompliant
  .ToList();  // x is sorted by Name, not sub-sorted
</pre>

<h2>Compliant Solution</h2>
<pre>
var x = personList
  .OrderBy(person => person.Age)
  .ThenBy(person => person.Name)
  .ToList();
</pre>
]]></description>
    <tag>bug</tag>
    <tag>performance</tag>
  </rule>
  <rule>
    <key>S1226</key>
    <name>Method parameters and caught exceptions should not be reassigned</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    While it is technically correct to assign to parameters from within method bodies, it is better to use temporary variables to store intermediate results.
    This rule will typically detect cases where a constructor parameter is assigned to itself instead of a field of the same name, i.e. when <code>this</code> was forgotten.
    Allowing parameters to be assigned to also reduces the code readability as developers will not be able to know whether the original parameter or some temporary variable is being accessed without going through the whole method.
    Moreover, some developers might also expect assignments of method parameters to be visible from callers, which is not the case and can confuse them.
    All parameters should be treated as <code>readonly</code>.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
class MyClass
{
  public string name;

  public MyClass(string name)
  {
    name = name;                    // Noncompliant - useless identity assignment
  }

  public int Add(int a, int b)
  {
    a = a + b;                      // Noncompliant

    /* additional logic */

    return a;                       // Seems like the parameter is returned as is, what is the point?
  }

  public static void Main()
  {
    MyClass foo = new MyClass();
    int a = 40;
    int b = 2;
    foo.Add(a, b);                  // Variable "a" will still hold 40 after this call
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
class MyClass
{
  public string name;

  public MyClass(string name)
  {
    this.name = name;               // Compliant
  }

  public int Add(int a, int b)
  {
    return a + b;                   // Compliant
  }

  public static void Main()
  {
    MyClass foo = new MyClass();
    int a = 40;
    int b = 2;
    foo.Add(a, b);
  }
}
</pre>

<h2>See</h2>
<ul>
    <li>MISRA C:2012, 17.8 - A function parameter should not be modified</li>
</ul>
]]></description>
    <tag>misra</tag>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S927</key>
    <name>"partial" method parameter names should match</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    When the parameters to the implementation of a <code>partial</code> method don't match those
    in the signature declaration, then confusion is almost guaranteed. Either the implementer was
    confused when he renamed, swapped or mangled the parameter names in the implementation, or
    callers will be confused.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
partial class Point
{
  partial void MoveVertically(int z);
}

partial class Point
{
  int x = 0;
  int y = 0;
  int z = 0;

  partial void MoveVertically(int y)  // Noncompliant
  {
    this.y = y;
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
partial class Point
{
  partial void MoveVertically(int z);
}

partial class Point
{
  int x = 0;
  int y = 0;
  int z = 0;

  partial void MoveVertically(int z)
  {
    this.z = z;
  }
}
</pre>

<h2>See</h2>

<ul>
    <li>MISRA C:2004, 8.3 - For each function parameter the type given in the declaration and definition shall be identical, and the return types shall also be identical</li>
    <li>MISRA C:2004, 16.4 - The identifiers used in the declaration and definition of a function shall be identical.</li>
    <li>MISRA C++:2008, 8-4-2 - The identifiers used for the parameters in a re-declaration of a function shall be identical to those in the declaration.</li>
    <li>MISRA C:2012, 8.3 - All declarations of an object or function shall use the same names and type qualifiers.</li>
</ul>]]></description>
    <tag>cert</tag>
    <tag>misra</tag>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S2234</key>
    <name>Parameters should be passed in the correct order</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    When the names of parameters in a method call match the names of the method arguments,
    it contributes to clearer, more readable code. However, when the names match, but are
    passed in a different order than the method arguments, it indicates a mistake in the
    parameter order which will likely lead to unexpected results.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public double divide(int divisor, int dividend)
{
  return divisor/dividend;
}

public void doTheThing()
{
  int divisor = 15;
  int dividend = 5;

  double result = divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected
  //...
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public double divide(int divisor, int dividend)
{
  return divisor/dividend;
}

public void doTheThing()
{
  int divisor = 15;
  int dividend = 5;

  double result = divide(divisor, dividend);
  //...
}
</pre>]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S2372</key>
    <name>Exceptions should not be thrown from property getters</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Property getters should be simple operations that are always safe to call. If exceptions need to be thrown, it is best to convert the property to a method.
</p>
<p>
    It is valid to throw exceptions from indexed property getters and from property setters, which are not detected by this rule.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
class MyClass
{
  public int Foo
  {
    get
    {
      throw new NotImplementedException();  //Non-Compliant
    }
    set
    {
      // ... some code ...
    }
  }
}
</pre>

<h2>Compliant Solution</h2>

<pre>
class MyClass
{
  public void SetFoo(int value)
  {
    // ... some code ...
  }
}
</pre>
]]></description>
    <tag>error-handling</tag>
  </rule>
  <rule>
    <key>S2292</key>
    <name>Trivial properties should be auto-implemented</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Trivial properties, which include no logic but setting and getting a backing field should be converted to auto-implemented
    properties, yielding cleaner and more readable code.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class Car
{
  private string _make;
  public string Make // Noncompliant
  {
    get { return _make; }
    set { _make = value; }
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public class Car
{
  public string Make { get; set; }
}
</pre>
]]></description>
    <tag>clumsy</tag>
  </rule>
  <rule>
    <key>S2376</key>
    <name>Write-only properties should not be used</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Properties with only setters are confusing and counterintuitive. Instead, a property getter should be added if possible, or
    the property should be replaced with a setter method.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
class Program
{
    public int Foo  //Non-Compliant
    {
        set
        {
            // ... some code ...
        }
    }
}
</pre>

<h2>Compliant Solution</h2>

<pre>
class Program
{
    public void SetFoo(int value)
    {
        // ... some code ...
    }
}
</pre>]]></description>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S2339</key>
    <name>Public constant members should not be used</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Constant members are copied at compile time to the call sites, instead of being fetched at runtime.
</p>
<p>
    As an example, say you have a library with a constant <code>Version</code> member set to <code>1.0</code>, and a
    client application linked to it. This library is then updated and <code>Version</code> is set to <code>2.0</code>.
    Unfortunately, even after the old DLL is replaced by the new one, <code>Version</code> will still be <code>1.0</code>
    for the client application. In order to see <code>2.0</code>, the client application would need to be rebuilt
    against the new version of the library.
</p>
<p>
    This means that you should use constants to hold values that by definition will never change, such as <code>Zero</code>.
    In practice, those cases are uncommon, and therefore it is generally better to avoid constant members.
</p>
<p>
    This rule only reports issues on public constant fields, which can be reached from outside the defining assembly.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class Foo
{
    public const double Version = 1.0;           // Noncompliant
}
</pre>

<h2>Compliant Solution</h2>

<pre>
public class Foo
{
    public static double Version
    {
      get { return 1.0; }
    }
}
</pre>
]]></description>
    <tag>convention</tag>
  </rule>
  <rule>
    <key>S2368</key>
    <name>Public methods should not have multidimensional array parameters</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Exposing methods with multidimensional array parameters require developers to have advanced knowledge about the language in
    order to be able to use them. Moreover, what exactly to pass to such parameters is not intuitive. Therefore, such methods
    should not be exposed, but can be used internally.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class Program
{
    public void WriteMatrix(int[][] matrix) // Non-Compliant
    {
    }
}
</pre>

<h2>Compliant Solution</h2>

<pre>
public class Matrix
{
    // ...
}

public class Program
{
    public void WriteMatrix(Matrix matrix) // Compliant
    {
    }
}
</pre>
]]></description>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S3254</key>
    <name>Default parameter values should not be passed as arguments</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Specifying the default parameter values in a method call is redundant. Such values should be omitted in the interests of readability.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public void M(int x, int y = 5, int z = 7) { /* ... */ }

// ...
M(1, 5); //Noncompliant, y has the default value
M(1, z: 7); //Noncompliant, z has the default value
</pre>

<h2>Compliant Solution</h2>
<pre>
public void M(int x, int y=5, int z = 7) { /* ... */ }

// ...
M(1);
M(1);
</pre>
]]></description>
    <tag>clumsy</tag>
  </rule>
  <rule>
    <key>S1905</key>
    <name>Redundant casts should not be used</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Unnecessary casting expressions make the code harder to read and understand.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public int Example(int i)
{
  return (int) (i + 42); // Noncompliant
}
public IEnumerable&lt;int&gt; ExampleCollection(IEnumerable&lt;int&gt; coll)
{
  return coll.Reverse().OfType&lt;int&gt;(); // Noncompliant
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public int Example(int i)
{
  return i + 42;
}
public IEnumerable&lt;int&gt; ExampleCollection(IEnumerable&lt;int&gt; coll)
{
  return coll.Reverse();
}
</pre>
]]></description>
    <tag>clumsy</tag>
  </rule>
  <rule>
    <key>S1939</key>
    <name>Inheritance list should not be redundant</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    An inheritance list entry is redundant if:
    <ul>
        <li>It is <code>Object</code> - all classes extend <code>Object</code> implicitly.</li>
        <li>It is <code>int</code> for an <code>enum</code></li>
        <li>It is a base class of another listed inheritance.</li>
    </ul>
    Such redundant declarations should be removed because they needlessly clutter the code and can be confusing.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class MyClass : Object  // Noncompliant

enum MyEnum : int  // Noncompliant
</pre>

<h2>Compliant Solution</h2>
<pre>
public class MyClass

enum MyEnum
</pre>
]]></description>
    <tag>clumsy</tag>
  </rule>
  <rule>
    <key>S2333</key>
    <name>Redundant modifiers should be removed</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Unnecessary keywords simply clutter the code and should be removed. Specifically:
    <ul>
        <li><code>virtual</code> on members of classes that are never overridden</li>
        <li><code>partial</code> on type declarations that are completely defined in one place</li>
        <li><code>sealed</code> on members of <code>sealed</code> classes</li>
    </ul>
</p>

<h2>Noncompliant Code Example</h2>
<pre>
internal partial class MyClass // Noncompliant;
{
  public virtual void DoSomething()  // Noncompliant; virtual is gratuitous
  {
    // ...
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
internal class MyClass
{
  public void DoSomething()
  {
    // ...
  }
}
</pre>
]]></description>
    <tag>unused</tag>
  </rule>
  <rule>
    <key>S3235</key>
    <name>Redundant parentheses should not be used</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Redundant parentheses are simply wasted keystrokes, and should be removed.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
[MyAttribute()] //Noncompliant
class MyClass
{
  public int MyProperty { get; set; }
  public static MyClass CreateNew(int propertyValue)
  {
    return new MyClass() //Noncompliant
    {
      MyProperty = propertyValue
    };
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
[MyAttribute]
class MyClass
{
  public int MyProperty { get; set; }
  public static MyClass CreateNew(int propertyValue)
  {
    return new MyClass
    {
      MyProperty = propertyValue
    };
  }
}
</pre>
]]></description>
    <tag>unused</tag>
  </rule>
  <rule>
    <key>S2995</key>
    <name>"Object.ReferenceEquals" should not be used for value types</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Using <code>Object.ReferenceEquals</code> to compare the references of two value types simply won't return the
    expected results most of the time because such types are passed by value, not by reference.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class MyClass
{
  private MyStruct myStruct;

  public void DoSomething(MyStruct s1) {
    int a = 1;
    int b = 1;

    if (Object.ReferenceEquals(myStruct, s1))  // Noncompliant; this can never be true
    {
      // ...
    }
    else if (Object.ReferenceEquals(a,b)) // Noncompliant
    {
      // ...
    }
  }
}
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S2757</key>
    <name>Reversed operators should not be used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    The use of operators pairs (<code>=+</code> or <code>=-</code>) where the reversed, single operator
    was meant (<code>+=</code> or <code>-=</code>) will compile and run, but not produce the expected results.
</p>
<p>
    This rule raises an issue when <code>=+</code>, and <code>=-</code> are used, but ignores the operators
    when they're spaced out: <code>= +</code>, <code>= -</code>.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
int target = -5;
int num = 3;

target =- num; // Noncompliant; target = -3. Is that really what's meant?
target =+ num; // Noncompliant; target = 3
</pre>

<h2>Compliant Solution</h2>
<pre>
int target = -5;
int num = 3;

target = -num; // Compliant; intent to assign inverse value of num is clear
target += num;
</pre>]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S1109</key>
    <name>A close curly brace should be located at the beginning of a line</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
Shared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the beginning of a line.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
if(condition)
{
  doSomething();}
</pre>

<h2>Compliant Solution</h2>
<pre>
if(condition)
{
  doSomething();
}
</pre>

<h2>Exceptions</h2>
<p>When blocks are inlined (open and close curly braces on the same line), no issue is triggered.</p>
<pre>
if(condition) { doSomething(); }
</pre>
]]></description>
    <tag>convention</tag>
  </rule>
  <rule>
    <key>S1656</key>
    <name>Variables should not be self-assigned</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake and some other value or variable was intended for the assignment instead.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public void setName(string name)
{
    name = name;
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public void setName(string name)
{
    this.name = name;
}
</pre>

<h2>See</h2>

<ul>
    <li> <a href="https://www.securecoding.cert.org/confluence/x/NYA5">CERT, MSC12-C</a> - Detect and remove code that has no effect</li>
    <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP</a> - Detect and remove code that has no effect</li>
</ul>]]></description>
    <tag>bug</tag>
    <tag>cert</tag>
  </rule>
  <rule>
    <key>S1697</key>
    <name>Short-circuit logic should be used to prevent null pointer dereferences in conditionals</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
When either the equality operator in a null test or the logical operator that follows it is reversed, the code has the appearance of safely null-testing the object before dereferencing it.
Unfortunately the effect is just the opposite - the object is null-tested and then dereferenced only if it is null, leading to a guaranteed null pointer dereference.
</p>

<h2>Noncompliant Code Sample</h2>
<pre>
if (str == null &amp;&amp; str.Length == 0)
{
  Console.WriteLine("String is empty");
}

if (str != null || str.Length > 0)
{
  Console.WriteLine("String is not empty");
}
</pre>

<h2>Compliant Solution</h2>
<pre>
if (str == null || str.Length == 0)
{
  Console.WriteLine("String is empty");
}

if (str != null &amp;&amp; str.Length > 0)
{
  Console.WriteLine("String is not empty");
}
</pre>]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S2437</key>
    <name>Silly bit operations should not be performed</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Certain bit operations are just silly and should not be performed because their results are predictable.
</p>
<p>
    Specifically, using <code>&amp; -1</code> with any value will always result in the original value, as will
    <code>anyValue ^ 0</code> and <code>anyValue | 0</code>.
</p>
]]></description>
    <tag>suspicious</tag>
  </rule>
  <rule>
    <key>S122</key>
    <name>Statements should be on separate lines</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    For better readability, do not put more than one statement on a single line.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
if(someCondition) doSomething();
</pre>

<h2>Compliant Solution</h2>

<pre>
if(someCondition) {
  doSomething();
}
</pre>

<h2>Exceptions</h2>
<p>
    Anonymous functions containing a single statement are ignored. Block statements are not considered either.
</p>
<pre>
Func&lt;object, bool&gt; item1 = o =&gt; { return true; }; // Compliant
Func&lt;object, bool&gt; item1 = o =&gt; { var r = false; return r; }; // Noncompliant
</pre>]]></description>
    <tag>convention</tag>
  </rule>
  <rule>
    <key>S2674</key>
    <name>The length returned from a stream read should be checked</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    You cannot assume that any given stream reading call will fill the <code>byte[]</code> passed in to the method with
    the number of bytes requested. Instead, you must check the value returned by the read method to see how many bytes
    were read. Fail to do so, and you introduce a bug that is both harmful and difficult to reproduce.
</p>
<p>
    This rule raises an issue when a <code>Stream.Read</code> or a <code>Stream.ReadAsync</code> method is called, but
    the return value is not checked.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public void DoSomething(string fileName)
{
  using (var stream = File.Open(fileName, FileMode.Open))
  {
    var result = new byte[stream.Length];
    stream.Read(result, 0, (int)stream.Length); // Noncompliant
    // ... do something with result
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public void DoSomething(string fileName)
{
  using (var stream = File.Open(fileName, FileMode.Open))
  {
    var buffer = new byte[1024];
    using (var ms = new MemoryStream())
    {
        int read;
        while ((read = stream.Read(buffer, 0, buffer.Length)) > 0)
        {
            ms.Write(buffer, 0, read);
        }
        // ... do something with ms
    }
  }
}
</pre>]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S2743</key>
    <name>Static fields should not be used in generic types</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    A static field in a generic type is not shared among instances of different closed constructed types, thus <code>LengthLimitedSingletonCollection&lt;int&gt;.instances</code>
    and <code>LengthLimitedSingletonCollection&lt;string&gt;.instances</code> will point to different objects, even though <code>instances</code> is seemingly shared among all
    <code>LengthLimitedSingletonCollection&lt;&gt;</code> generic classes.
</p>
<p>
    If you need to have a static field shared among instances with different generic arguments, define a non-generic base class to store your static members, then set your generic type to inherit from the base class.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class LengthLimitedSingletonCollection&lt;T&gt; where T : new()
{
  protected const int MaxAllowedLength = 5;
  protected static Dictionary&lt;Type, object&gt; instances = new Dictionary&lt;Type, object&gt;(); // Noncompliant
  public static T GetInstance()
  {
    object instance;
    if (!instances.TryGetValue(typeof(T), out instance))
    {
      if (instances.Count >= MaxAllowedLength)
      {
        throw new Exception();
      }
      instance = new T();
      instances.Add(typeof(T), instance);
    }
    return (T)instance;
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public class SingletonCollectionBase
{
  protected static Dictionary&lt;Type, object&gt; instances = new Dictionary&lt;Type, object&gt;();
}
public class LengthLimitedSingletonCollection&lt;T&gt; : SingletonCollectionBase where T : new()
{
  protected const int MaxAllowedLength = 5;
  public static T GetInstance()
  {
    object instance;
    if (!instances.TryGetValue(typeof(T), out instance))
    {
      if (instances.Count >= MaxAllowedLength)
      {
        throw new Exception();
      }
      instance = new T();
      instances.Add(typeof(T), instance);
    }
    return (T)instance;
  }
}
</pre>

<h2>Exception</h2>
<p>
    If the static field or property uses a type parameter, then the developer is assumed to understand that the static member is not shared among the closed constructed types.
</p>
<pre>
public class Cache&lt;T&gt;
{
  private static Dictionary&lt;string, T&gt; CacheDictionary { get; set; } // Compliant
}
</pre>
]]></description>
  </rule>
  <rule>
    <key>S3263</key>
    <name>Static fields should appear in the order they must be initialized</name>
    <severity>BLOCKER</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Static field initializers are executed in the order in which they appear in the class from top to bottom. Thus,
    placing a static field in a class above the field or fields required for its initialization will yield unexpected
    results.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
class MyClass
{
  public static int X = Y; // Noncompliant; Y at this time is still assigned default(int), i.e. 0
  public static int Y = 42;
}
</pre>

<h2>Compliant Solution</h2>
<pre>
class MyClass
{
  public static int Y = 42;
  public static int X = Y;
}
</pre>
or
<pre>
class MyClass
{
  public static int X;
  public static int Y = 42;

  static MyClass()
  {
    X = Y;
  }
}
</pre>]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S2223</key>
    <name>Non-constant static fields should not be visible</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    A <code>static</code> field that is neither constant nor read-only is not thread-safe. Correctly accessing
    these fields from different threads needs synchronization with <code>lock</code>s. Improper synchronization
    may lead to unexpected results, thus publicly visible static fields are best suited for storing non-changing
    data shared by many consumers. To enforce this intent, these fields should be marked <code>readonly</code> or
    converted to a constant.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class Math
{
  public static double Pi = 3.14;  // Noncompliant
}
</pre>
or
<pre>
public class Shape
{
  public static Shape Empty = new EmptyShape();  // Noncompliant

  private class EmptyShape : Shape
  {
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public class Math
{
  public const double Pi = 3.14;
}
</pre>
or
<pre>
public class Shape
{
  public static readonly Shape Empty = new EmptyShape();

  private class EmptyShape : Shape
  {
  }
}
</pre>]]></description>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S2696</key>
    <name>Instance members should not write to "static" fields</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Correctly updating a <code>static</code> field from a non-static method is tricky to get right and could easily lead to
    bugs if there are multiple class instances and/or multiple threads in play.
</p>
<p>
    This rule raises an issue each time a <code>static</code> field is updated from a non-static method or property.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class MyClass
{
  private static int count = 0;

  public void DoSomething()
  {
    //...
    count++;  // Noncompliant
  }
}
</pre>
]]></description>
    <tag>bug</tag>
    <tag>multi-threading</tag>
  </rule>
  <rule>
    <key>S1643</key>
    <name>Strings should not be concatenated using "+" in a loop</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    <code>StringBuilder</code> is more efficient than string concatenation, especially when the operator is repeated over and over as in loops.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
string str = "";
for (int i = 0; i &lt; arrayOfStrings.Length; ++i)
{
  str = str + arrayOfStrings[i];
}
</pre>

<h2>Compliant Solution</h2>

<pre>
StringBuilder bld = new StringBuilder();
for (int i = 0; i &lt; arrayOfStrings.Length; ++i)
{
  bld.Append(arrayOfStrings[i]);
}
string str = bld.ToString();
</pre>
]]></description>
    <tag>performance</tag>
  </rule>
  <rule>
    <key>S1449</key>
    <name>Culture should be specified for String operations</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    <code>String.ToLower()</code>, <code>.ToUpper</code>, <code>.Compare</code>, and
    <code>.Equals</code> are all culture-dependent, as are some (floating point number-related) calls to ToString. Fortunately, all have
    variants which accept an argument specifying the culture or formatter to use. Leave that argument off and the call will use the
    system default culture, possibly creating problems with international characters.
</p>
<p>
    Such calls without a culture may work fine in the system's "home" environment, but break in ways that are extremely difficult to
    diagnose for customers who use different encodings. Such bugs can be nearly, if not completely, impossible to reproduce when it's
    time to fix them.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
var lowered = someString.ToLower(); //Noncompliant
</pre>

<h2>Compliant Solution</h2>
<pre>
var lowered = someString.ToLower(CultureInfo.InvariantCulture);
</pre>
or
<pre>
var lowered = someString.ToLowerInvariant();
</pre>
]]></description>
    <tag>unpredictable</tag>
  </rule>
  <rule>
    <key>S2275</key>
    <name>Format strings should be passed the correct number of arguments</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Use fewer arguments than are expected in your format string, and you'll get an error at runtime. Use more arguments than are
    expected, and you probably won't get the output you expect. Either way, it's a bug.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
var s1 = string.Format("{0} {1} {2}", 1, 2); // Noncompliant; too few arguments
var s2 = string.Format("{0}", 10, 11); // Noncompliant; too many arguments
</pre>

<h2>Compliant Solution</h2>
<pre>
// Pass the expected number of arguments
var s1 = string.Format("{0} {1} {2}", 1, 2, 3);
var s2 = string.Format("{0}", 10);
</pre>
or
<pre>
// Fix the format string
var s1 = string.Format("{0} {1}", 1, 2);
var s2 = string.Format("{0} {1}", 10, 11);
</pre>
]]></description>
    <tag>bug</tag>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S3234</key>
    <name>"GC.SuppressFinalize" should not be invoked for types without destructors</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    <code>GC.SuppressFinalize</code> asks the Common Language Runtime not to call the finalizer of an object. This is useful when
    implementing the dispose pattern where object finalization is already handled in <code>IDisposable.Dispose</code>. However, it
    has no effect if there is no finalizer defined in the object's type, so using it in such cases is just confusing.
</p>
<p>
    This rule raises an issue when <code>GC.SuppressFinalize</code> is called for objects of <code>sealed</code> types without a finalizer.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
sealed class MyClass
{
  public void Method()
  {
    ...
    GC.SuppressFinalize(this); //Noncompliant
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
sealed class MyClass
{
  public void Method()
  {
    ...
  }
}
</pre>
]]></description>
    <tag>confusing</tag>
    <tag>unused</tag>
  </rule>
  <rule>
    <key>S1301</key>
    <name>"switch" statements should have at least 3 "case" clauses</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    <code>switch</code> statements are useful when there are many different cases depending on the value of the same expression.
</p>
<p>
    For just one or two cases however, the code will be more readable with <code>if</code> statements.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
switch (variable)
{
  case 0:
    doSomething();
    break;
  default:
    doSomethingElse();
    break;
}
</pre>

<h2>Compliant Solution</h2>
<pre>
if (variable == 0)
{
  doSomething();
} else
{
  doSomethingElse();
}
</pre>

<h2>See</h2>
<ul>
    <li>MISRA C:2004, 15.5 - Every switch statement shall have at least one case clause.</li>
    <li>MISRA C++:2008, 6-4-8 - Every switch statement shall have at least one case-clause.</li>
    <li>MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses</li>
</ul>]]></description>
    <tag>misra</tag>
  </rule>
  <rule>
    <key>S131</key>
    <name>"switch/Select" statements should end with a "default/Case Else" clause</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    The requirement for a final <code>default</code> clause is defensive programming. The clause should either take
    appropriate action, or contain a suitable comment as to why no action is taken. Even when the <code>switch</code>
    covers all current values of an <code>enum</code>, a <code>default</code> case should still be used because there is
    no guarantee that the <code>enum</code> won't be extended.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
int foo = 42;
switch (foo) // Noncompliant
{
  case 0:
    Console.WriteLine("foo = 0");
    break;
  case 42:
    Console.WriteLine("foo = 42");
    break;
}
</pre>

<h2>Compliant Solution</h2>

<pre>
int foo = 42;
switch (foo) // Compliant
{
  case 0:
    Console.WriteLine("foo = 0");
    break;
  case 42:
    Console.WriteLine("foo = 42");
    break;
  default:
    throw new InvalidOperationException("Unexpected value foo = " + foo);
}
</pre>

<h2>See</h2>

<ul>
    <li>MISRA C:2004, 15.0 - The MISRA C switch syntax shall be used.</li>
    <li>MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause</li>
    <li>MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement.</li>
    <li>MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause</li>
    <li>MISRA C:2012, 16.1 - All switch statements shall be well-formed</li>
    <li>MISRA C:2012, 16.4 - Every switch statement shall have a default label</li>
    <li>MISRA C:2012, 16.5 - A default label shall appear as either the first or the last switch label of a switch statement</li>
    <li><a href="http://cwe.mitre.org/data/definitions/478.html">MITRE, CWE-478</a> - Missing Default Case in Switch Statement</li>
    <li><a href="https://www.securecoding.cert.org/confluence/x/YgE">CERT, MSC01-C</a> - Strive for logical completeness</li>
    <li><a href="https://www.securecoding.cert.org/confluence/x/JoIyAQ">CERT, MSC01-CPP</a> - Strive for logical completeness</li>
</ul>]]></description>
    <tag>cert</tag>
    <tag>cwe</tag>
    <tag>misra</tag>
  </rule>
  <rule>
    <key>S105</key>
    <name>Tabulation characters should not be used</name>
    <severity>MINOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
Developers should not need to configure the tab width of their text editors in order to be able to read source code.
So the use of tabulation character must be banned.
</p>
]]></description>
    <tag>convention</tag>
  </rule>
  <rule>
    <key>S2758</key>
    <name>The ternary operator should not return the same value regardless of the condition</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    When the second and third operands of a ternary operator are the same, the operator will always
    return the same value regardless of the condition. Either the operator itself is pointless, or a
    mistake was made in coding it.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public boolean canVote(Person person)
{
  return person.getAge > 18 ? true : true; // Noncompliant; is this what was intended?
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public boolean canVote(Person person)
{
  return person.getAge > 18 ? true : false;
}
</pre>]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S3005</key>
    <name>"ThreadStatic" should not be used on non-static fields</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    When a non-<code>static</code> class field is annotated with <code>ThreadStatic</code>, the code seems to show that the
    field can have different values for different calling threads, but that's not the case, since the <code>ThreadStatic</code>
    attribute is simply ignored on non-<code>static</code> fields.
</p>
<p>
    So <code>ThreadStatic</code> should either be removed or replaced with a use of the <code>ThreadLocal&lt;T&gt;</code> class,
    which gives a similar behavior for non-<code>static</code> fields.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class MyClass
{
  [ThreadStatic]  // Noncompliant
  private int count = 0;

  // ...
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public class MyClass
{
  private int count = 0;

  // ...
}
</pre>
or
<pre>
public class MyClass
{
  private readonly ThreadLocal&lt;int&gt; count = new ThreadLocal&lt;int&gt;();
  public int Count
  {
    get { return count.Value; }
    set { count.Value = value; }
  }
  // ...
}
</pre>
]]></description>
    <tag>bug</tag>
    <tag>unused</tag>
  </rule>
  <rule>
    <key>S2996</key>
    <name>"ThreadStatic" fields should not be initialized</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    When an object has a field annotated with <code>ThreadStatic</code>, that field is shared within a given thread,
    but unique across threads. Since a class' static initializer is only invoked for the
    first thread created, it also means that only the first thread will have the expected initial values.
</p>
<p>
    Instead, allow such fields to be initialized to their default values or make the initialization lazy.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public class Foo
{
  [ThreadStatic]
  public static object PerThreadObject = new object(); // Noncompliant. Will be null in all the threads except the first one.
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public class Foo
{
  [ThreadStatic]
  public static object _perThreadObject;
  public static object PerThreadObject
  {
    get
    {
      if (_perThreadObject == null)
      {
        _perThreadObject = new object();
      }
      return _perThreadObject;
    }
  }
}
</pre>
]]></description>
    <tag>bug</tag>
    <tag>multi-threading</tag>
  </rule>
  <rule>
    <key>S1479</key>
    <name>"switch" statements should not have too many "case" clauses</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
  When <code>switch</code> statements have a large set of <code>case</code> clauses, it is usually an attempt to map two sets of data. A real map structure would be more readable and maintainable, and should be used instead.
</p>
]]></description>
    <tag>brain-overload</tag>
    <param>
      <key>maximum</key>
      <description><![CDATA[Maximum number of case]]></description>
      <type>INTEGER</type>
      <defaultValue>30</defaultValue>
    </param>
  </rule>
  <rule>
    <key>S107</key>
    <name>Methods should not have too many parameters</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
A long parameter list can indicate that a new structure should be created to wrap the numerous parameters or that the function is doing too many things.
</p>

<h2>Noncompliant Code Example</h2>
<p>The following code snippet illustrates this rule with a maximum number of 4 parameters:</p>
<pre>
public void doSomething(int param1, int param2, int param3, string param4, long param5)
{
...
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public void doSomething(int param1, int param2, int param3, string param4)
{
...
}
</pre>
]]></description>
    <tag>brain-overload</tag>
    <param>
      <key>max</key>
      <description><![CDATA[Maximum authorized number of parameters]]></description>
      <type>INTEGER</type>
      <defaultValue>7</defaultValue>
    </param>
  </rule>
  <rule>
    <key>S2225</key>
    <name>"ToString()" method should not return null</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Calling <code>ToString()</code> on an object should always return a string. Returning <code>null</code> instead contravenes the method's implicit contract.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public override string ToString ()
{
  if (this.collection.Count == 0)
  {
    return null; // Noncompliant
  }
  else
  {
    // ...

</pre>

<h2>Compliant Solution</h2>
<pre>
public override string ToString ()
{
  if (this.collection.Count == 0)
  {
    return "";
  }
  else
  {
    // ...

</pre>

<h2>See</h2>

<ul>
    <li><a href="http://cwe.mitre.org/data/definitions/476.html">MITRE CWE-476</a> - NULL Pointer Dereference</li>
</ul>
]]></description>
    <tag>bug</tag>
    <tag>cwe</tag>
  </rule>
  <rule>
    <key>S2761</key>
    <name>Doubled prefix operators "!!" and "~~" should not be used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Calling the <code>!</code> or <code>~</code> prefix operator twice does nothing: the second invocation undoes the first.
    Such mistakes are typically caused by accidentally double-tapping the key in question without noticing.
</p>
<p>
    Either this is a bug, if the operator was actually meant to be called once, or misleading if done on purpose.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
int v1 = 0;
bool v2 = false;

var v3 = !!v1; // Noncompliant
var v4 = ~~v2; // Noncompliant
</pre>

<h2>Compliant Solution</h2>
<pre>
int v1 = 0;
bool v2 = false;

var v3 = !v1;
var v4 = ~v2;
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S121</key>
    <name>Control structures should use curly braces</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
  While not technically incorrect, the omission of curly braces can be misleading, and may lead to the introduction of errors during maintenance.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
// the two statements seems to be attached to the if statement, but that is only true for the first one:
if (condition)
  executeSomething();
  checkSomething();
</pre>

<h2>Compliant Solution</h2>
<pre>
if (condition)
{
  executeSomething();
  checkSomething();
}
</pre>

<h2>See</h2>

<ul>
    <li>MISRA C:2004, 14.8 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement</li>
    <li>MISRA C:2004, 14.9 - An if (expression) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement</li>
    <li>MISRA C++:2008, 6-3-1 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement</li>
    <li>MISRA C++:2008, 6-4-1 - An if (condition) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement</li>
    <li>MISRA C:2012, 15.6 - The body of an iteration-statement or a selection-statement shall be a compound-statement</li>
    <li> <a href="https://www.securecoding.cert.org/confluence/x/1QGMAg">CERT, EXP19-C</a> - Use braces for the body of an if, for, or while statement</li>
    <li> <a href="http://cwe.mitre.org/data/definitions/483.html">MITRE, CWE-483</a> - Incorrect Block Delimitation</li>
</ul>
]]></description>
    <tag>cert</tag>
    <tag>cwe</tag>
    <tag>misra</tag>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S3237</key>
    <name>"value" parameters should be used</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    In property and indexer <code>set</code> methods, and in event <code>add</code> and <code>remove</code> methods, the implicit
    <code>value</code> parameter holds the value the accessor was called with. Not using the <code>value</code> means that the
    accessor ignores the caller's intent which could cause unexpected results at runtime.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
private int count;
public int Count
{
  get { return count; }
  set { count = 42; } // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
private int count;
public int Count
{
  get { return count; }
  set { count = value; }
}
</pre>
or
<pre>
public int Count
{
  get { return count; }
  set { throw new InvalidOperationException(); }
}
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S2123</key>
    <name>Values should not be uselessly incremented</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public int pickNumber()
{
  int i = 0;
  int j = 0;

  i = i++; // Noncompliant; i is still zero

  return j++; // Noncompliant; 0 returned
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public int pickNumber()
{
  int i = 0;
  int j = 0;

  i++;
  return ++j;
}
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
  <rule>
    <key>S1117</key>
    <name>Local variables should not shadow class fields</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Shadowing fields with a local variable or with a method parameter is a bad practice that
    reduces code readability: It makes it confusing to know whether the field or the variable
    is being used.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
class Foo
{
  public int myField;

  public void doSomething()
  {
    int myField = 0;
    ...
  }

  public void doSomethingElse(int myField)
  {
    ...
  }
}
</pre>

<h2>Exceptions</h2>
<p>
    Constructors are exceptions; it is common practice to name arguments for the fields the
    values will be assigned to. Static methods are also excepted.
</p>

<pre>
class Foo {
  public int myField;

  public Foo(int myField)
  {
    this.myField = myField;
  }

  public static Foo build(int myField)
  {
    ...
  }
}
</pre>
]]></description>
    <tag>pitfall</tag>
  </rule>
  <rule>
    <key>S1481</key>
    <name>Unused local variables should be removed</name>
    <severity>MAJOR</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will not wonder what the variable is used for.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
public int numberOfMinutes(int hours)
{
  int seconds = 0;   // seconds is never used
  return hours * 60;
}
</pre>

<h2>Compliant Solution</h2>
<pre>
public int numberOfMinutes(int hours)
{
  return hours * 60;
}
</pre>

<h2>Exceptions</h2>
<p>
    Unused locally created resources in a <code>using</code> statement are not reported.
</p>
<pre>
using(var t = new Timer()) // t never used, but compliant.
{
  //...
}
</pre>
]]></description>
    <tag>unused</tag>
  </rule>
  <rule>
    <key>S2290</key>
    <name>Field-like events should not be virtual</name>
    <severity>CRITICAL</severity>
    <cardinality>SINGLE</cardinality>
    <description><![CDATA[<p>
    Field-like events are events that do not have explicit <code>add</code> and <code>remove</code> methods. The compiler
    generates a <code>private</code> <code>delegate</code> field to back the event, as well as generating the implicit
    <code>add</code> and <code>remove</code> methods.
</p>
<p>
    When a <code>virtual</code> field-like <code>event</code> is overridden by another field-like <code>event</code>,
    the behavior of the C# compiler is to generate a new <code>private</code> <code>delegate</code> field in the derived
    class, separate from the parent's field. This results in multiple and separate events being created, which is rarely
    what's actually intended.
</p>
<p>
    To prevent this, remove the <code>virtual</code> designation from the parent class event.
</p>

<h2>Noncompliant Code Example</h2>
<pre>
abstract class Car
{
  public virtual event EventHandler OnRefueled; // Noncompliant

  public void Refuel()
  {
    // This OnRefueld will always be null
     if (OnRefueled != null)
     {
       OnRefueled(this, null);
     }
  }
}

class R2 : Car
{
  public override event EventHandler OnRefueled;
}

class Program
{
  static void Main(string[] args)
  {
    var r2 = new R2();
    r2.OnRefueled += new EventHandler((o, a) =>
    {
      Console.WriteLine("This event will never be called");
    });
    r2.Refuel();
  }
}
</pre>

<h2>Compliant Solution</h2>
<pre>
abstract class Car
{
  public event EventHandler OnRefueled; // Compliant

  public void Refuel()
  {
    if (OnRefueled != null)
    {
      OnRefueled(this, null);
    }
  }
}

class R2 : Car {}

class Program
{
  static void Main(string[] args)
  {
    var r2 = new R2();
    r2.OnRefueled += new EventHandler((o, a) =>
    {
      Console.WriteLine("This event will be called");
    });
    r2.Refuel();
  }
}
</pre>
]]></description>
    <tag>bug</tag>
  </rule>
</rules>