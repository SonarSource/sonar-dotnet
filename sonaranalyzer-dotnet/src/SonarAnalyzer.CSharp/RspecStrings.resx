<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="S100_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S100_Description" xml:space="preserve">
    <value>Shared naming conventions allow teams to collaborate efficiently. This rule checks whether or not method and property names are camel cased. To reduce noise, two consecutive upper case characters are allowed unless they form the whole name. So, MyXMethod is compliant, but XM on its own is not.</value>
  </data>
  <data name="S100_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S100_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S100_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S100_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S100_Tags" xml:space="preserve">
    <value>convention</value>
  </data>
  <data name="S100_Title" xml:space="preserve">
    <value>Methods and properties should be named in camel case</value>
  </data>
  <data name="S1006_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1006_Description" xml:space="preserve">
    <value>Default arguments are determined by the static type of the object. If a default argument is different for a parameter in an overriding method, the value used in the call will be different when calls are made via the base or derived object, which may be contrary to developer expectations. </value>
  </data>
  <data name="S1006_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1006_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1006_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S1006_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S1006_Tags" xml:space="preserve">
    <value>misra,cert,pitfall</value>
  </data>
  <data name="S1006_Title" xml:space="preserve">
    <value>Method overrides should not change parameter defaults</value>
  </data>
  <data name="S101_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S101_Description" xml:space="preserve">
    <value>Shared naming conventions allow teams to collaborate efficiently. This rule checks whether or not type names are camel cased. To reduce noise, two consecutive upper case characters are allowed unless they form the whole type name. So, MyXClass is compliant, but XC on its own is not.</value>
  </data>
  <data name="S101_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S101_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S101_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S101_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S101_Tags" xml:space="preserve">
    <value>convention</value>
  </data>
  <data name="S101_Title" xml:space="preserve">
    <value>Types should be named in camel case</value>
  </data>
  <data name="S103_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S103_Description" xml:space="preserve">
    <value>Having to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.</value>
  </data>
  <data name="S103_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S103_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S103_RemediationCost" xml:space="preserve">
    <value>1min</value>
  </data>
  <data name="S103_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S103_Tags" xml:space="preserve">
    <value>convention</value>
  </data>
  <data name="S103_Title" xml:space="preserve">
    <value>Lines should not be too long</value>
  </data>
  <data name="S104_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S104_Description" xml:space="preserve">
    <value>A source file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain. Above a specific threshold, it is strongly advised to refactor it into smaller pieces of code which focus on well defined tasks. Those smaller files will not only be easier to understand but also probably easier to test.</value>
  </data>
  <data name="S104_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S104_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S104_RemediationCost" xml:space="preserve">
    <value>1h</value>
  </data>
  <data name="S104_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S104_Tags" xml:space="preserve">
    <value>brain-overload</value>
  </data>
  <data name="S104_Title" xml:space="preserve">
    <value>Files should not have too many lines of code</value>
  </data>
  <data name="S105_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S105_Description" xml:space="preserve">
    <value>Developers should not need to configure the tab width of their text editors in order to be able to read source code.</value>
  </data>
  <data name="S105_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S105_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S105_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S105_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S105_Tags" xml:space="preserve">
    <value>convention</value>
  </data>
  <data name="S105_Title" xml:space="preserve">
    <value>Tabulation characters should not be used</value>
  </data>
  <data name="S1066_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1066_Description" xml:space="preserve">
    <value>Merging collapsible if statements increases the code's readability.</value>
  </data>
  <data name="S1066_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1066_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1066_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1066_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1066_Tags" xml:space="preserve">
    <value>clumsy</value>
  </data>
  <data name="S1066_Title" xml:space="preserve">
    <value>Collapsible "if" statements should be merged</value>
  </data>
  <data name="S1067_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1067_Description" xml:space="preserve">
    <value>The complexity of an expression is defined by the number of &amp;amp;&amp;amp;, || and condition ? ifTrue : ifFalse operators it contains.</value>
  </data>
  <data name="S1067_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1067_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1067_RemediationCost" xml:space="preserve">
    <value>3min</value>
  </data>
  <data name="S1067_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S1067_Tags" xml:space="preserve">
    <value>brain-overload</value>
  </data>
  <data name="S1067_Title" xml:space="preserve">
    <value>Expressions should not be too complex</value>
  </data>
  <data name="S107_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S107_Description" xml:space="preserve">
    <value>A long parameter list can indicate that a new structure should be created to wrap the numerous parameters or that the function is doing too many things.</value>
  </data>
  <data name="S107_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S107_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S107_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S107_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S107_Tags" xml:space="preserve">
    <value>brain-overload</value>
  </data>
  <data name="S107_Title" xml:space="preserve">
    <value>Methods should not have too many parameters</value>
  </data>
  <data name="S108_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S108_Description" xml:space="preserve">
    <value>Most of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed.</value>
  </data>
  <data name="S108_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S108_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S108_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S108_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S108_Tags" xml:space="preserve">
    <value>suspicious</value>
  </data>
  <data name="S108_Title" xml:space="preserve">
    <value>Nested blocks of code should not be left empty</value>
  </data>
  <data name="S110_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S110_Description" xml:space="preserve">
    <value>Inheritance is certainly one of the most valuable concepts in object-oriented programming. It's a way to compartmentalize and reuse code by creating collections of attributes and behaviors called classes which can be based on previously created classes. But abusing this concept by creating a deep inheritance tree can lead to very complex and unmaintainable source code. Most of the time a too deep inheritance tree is due to bad object oriented design which has led to systematically use 'inheritance' when for instance 'composition' would suit better.</value>
  </data>
  <data name="S110_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S110_Remediation" xml:space="preserve">
    <value />
  </data>
  <data name="S110_RemediationCost" xml:space="preserve">
    <value />
  </data>
  <data name="S110_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S110_Tags" xml:space="preserve">
    <value>design</value>
  </data>
  <data name="S110_Title" xml:space="preserve">
    <value>Inheritance tree of classes should not be too deep</value>
  </data>
  <data name="S1104_Category" xml:space="preserve">
    <value>Sonar Vulnerability</value>
  </data>
  <data name="S1104_Description" xml:space="preserve">
    <value>Public fields in public classes do not respect the encapsulation principle and has three main disadvantages:</value>
  </data>
  <data name="S1104_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1104_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1104_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S1104_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1104_Tags" xml:space="preserve">
    <value>cwe,security</value>
  </data>
  <data name="S1104_Title" xml:space="preserve">
    <value>Fields should not have public accessibility</value>
  </data>
  <data name="S1109_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1109_Description" xml:space="preserve">
    <value>Shared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the beginning of a line.</value>
  </data>
  <data name="S1109_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1109_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1109_RemediationCost" xml:space="preserve">
    <value>1min</value>
  </data>
  <data name="S1109_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1109_Tags" xml:space="preserve">
    <value>convention</value>
  </data>
  <data name="S1109_Title" xml:space="preserve">
    <value>A close curly brace should be located at the beginning of a line</value>
  </data>
  <data name="S1116_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1116_Description" xml:space="preserve">
    <value>Empty statements, i.e. ;, are usually introduced by mistake, for example because:</value>
  </data>
  <data name="S1116_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1116_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1116_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S1116_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1116_Tags" xml:space="preserve">
    <value>misra,cert,unused</value>
  </data>
  <data name="S1116_Title" xml:space="preserve">
    <value>Empty statements should be removed</value>
  </data>
  <data name="S1117_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1117_Description" xml:space="preserve">
    <value>Shadowing fields with a local variable is a bad practice that reduces code readability: it makes it confusing to know whether the field or the variable is being used.</value>
  </data>
  <data name="S1117_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1117_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1117_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1117_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1117_Tags" xml:space="preserve">
    <value>cert,pitfall</value>
  </data>
  <data name="S1117_Title" xml:space="preserve">
    <value>Local variables should not shadow class fields</value>
  </data>
  <data name="S1118_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1118_Description" xml:space="preserve">
    <value>Utility classes, which are collections of static members, are not meant to be instantiated. Even abstract utility classes, which can be extended, should not have public constructors.</value>
  </data>
  <data name="S1118_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1118_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1118_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S1118_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1118_Tags" xml:space="preserve">
    <value>design</value>
  </data>
  <data name="S1118_Title" xml:space="preserve">
    <value>Utility classes should not have public constructors</value>
  </data>
  <data name="S112_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S112_Description" xml:space="preserve">
    <value>Throwing such general exceptions as Exception, SystemException, ApplicationException, IndexOutOfRangeException, NullReferenceException, OutOfMemoryException and ExecutionEngineException prevents calling methods from handling true, system-generated exceptions differently than application-generated errors. </value>
  </data>
  <data name="S112_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S112_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S112_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S112_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S112_Tags" xml:space="preserve">
    <value>cwe,error-handling,cert</value>
  </data>
  <data name="S112_Title" xml:space="preserve">
    <value>General exceptions should never be thrown</value>
  </data>
  <data name="S1121_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1121_Description" xml:space="preserve">
    <value>Assignments within sub-expressions are hard to spot and therefore make the code less readable. Ideally, sub-expressions should not have side-effects.</value>
  </data>
  <data name="S1121_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1121_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1121_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1121_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1121_Tags" xml:space="preserve">
    <value>cwe,misra,cert,suspicious</value>
  </data>
  <data name="S1121_Title" xml:space="preserve">
    <value>Assignments should not be made from within sub-expressions</value>
  </data>
  <data name="S1125_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1125_Description" xml:space="preserve">
    <value>Redundant Boolean literals should be removed from expressions to improve readability.</value>
  </data>
  <data name="S1125_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1125_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1125_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S1125_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1125_Tags" xml:space="preserve">
    <value>clumsy</value>
  </data>
  <data name="S1125_Title" xml:space="preserve">
    <value>Boolean literals should not be redundant</value>
  </data>
  <data name="S1134_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1134_Description" xml:space="preserve">
    <value>FIXME tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.</value>
  </data>
  <data name="S1134_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1134_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1134_Tags" xml:space="preserve">
    <value>cwe</value>
  </data>
  <data name="S1134_Title" xml:space="preserve">
    <value>Track uses of "FIXME" tags</value>
  </data>
  <data name="S1135_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1135_Description" xml:space="preserve">
    <value>TODO tags are commonly used to mark places where some more code is required, but which the developer wants to implement later.</value>
  </data>
  <data name="S1135_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1135_Severity" xml:space="preserve">
    <value>Info</value>
  </data>
  <data name="S1135_Tags" xml:space="preserve">
    <value>cwe</value>
  </data>
  <data name="S1135_Title" xml:space="preserve">
    <value>Track uses of "TODO" tags</value>
  </data>
  <data name="S1144_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1144_Description" xml:space="preserve">
    <value>Private, or internal, types or members that are never executed or referenced are dead code: unnecessary, inoperative code that should be removed. Cleaning out dead code decreases the size of the maintained codebase, making it easier to understand the program and preventing bugs from being introduced.</value>
  </data>
  <data name="S1144_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1144_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1144_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1144_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1144_Tags" xml:space="preserve">
    <value>cert,unused</value>
  </data>
  <data name="S1144_Title" xml:space="preserve">
    <value>Unused private types or members should be removed</value>
  </data>
  <data name="S1145_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S1145_Description" xml:space="preserve">
    <value>if statements with conditions that are always false have the effect of making blocks of code non-functional. if statements with conditions that are always true are completely redundant, and make the code less readable.</value>
  </data>
  <data name="S1145_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1145_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1145_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S1145_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1145_Tags" xml:space="preserve">
    <value>cwe,bug,misra</value>
  </data>
  <data name="S1145_Title" xml:space="preserve">
    <value>Useless "if(true) {...}" and "if(false){...}" blocks should be removed</value>
  </data>
  <data name="S1155_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1155_Description" xml:space="preserve">
    <value>Using .Count() to test for emptiness works, but using .Any() makes the intent clearer, and the code more readable. However, there are some cases where special attention should be paid:</value>
  </data>
  <data name="S1155_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1155_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1155_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S1155_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1155_Tags" xml:space="preserve">
    <value>clumsy</value>
  </data>
  <data name="S1155_Title" xml:space="preserve">
    <value>"Any()" should be used to test for emptiness</value>
  </data>
  <data name="S1163_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1163_Description" xml:space="preserve">
    <value>Throwing an exception from within a finally block will mask any exception which was previously thrown in the try or catch block, and the masked's exception message and stack trace will be lost.</value>
  </data>
  <data name="S1163_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1163_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1163_RemediationCost" xml:space="preserve">
    <value>30min</value>
  </data>
  <data name="S1163_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S1163_Tags" xml:space="preserve">
    <value>error-handling,cert,suspicious</value>
  </data>
  <data name="S1163_Title" xml:space="preserve">
    <value>Exceptions should not be thrown in finally blocks</value>
  </data>
  <data name="S1172_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1172_Description" xml:space="preserve">
    <value>Unused parameters are misleading. Whatever the values passed to such parameters, the behavior will be the same.</value>
  </data>
  <data name="S1172_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1172_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1172_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1172_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1172_Tags" xml:space="preserve">
    <value>misra,cert,unused</value>
  </data>
  <data name="S1172_Title" xml:space="preserve">
    <value>Unused method parameters should be removed</value>
  </data>
  <data name="S1185_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1185_Description" xml:space="preserve">
    <value>Overriding a method just to call the same method from the base class without performing any other actions is useless and misleading. The only time this is justified is in sealed overriding methods, where the effect is to lock in the parent class behavior. This rule ignores overrides of Equals and GetHashCode.</value>
  </data>
  <data name="S1185_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1185_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1185_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S1185_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1185_Tags" xml:space="preserve">
    <value>redundant,clumsy</value>
  </data>
  <data name="S1185_Title" xml:space="preserve">
    <value>Overriding members should do more than simply call the same member in the base class</value>
  </data>
  <data name="S1186_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1186_Description" xml:space="preserve">
    <value>There are several reasons for a method not to have a method body:</value>
  </data>
  <data name="S1186_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1186_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1186_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1186_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S1186_Tags" xml:space="preserve">
    <value>suspicious</value>
  </data>
  <data name="S1186_Title" xml:space="preserve">
    <value>Methods should not be empty</value>
  </data>
  <data name="S1206_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S1206_Description" xml:space="preserve">
    <value>There is a contract between Equals(object) and GetHashCode(): If two objects are equal according to the Equals(object) method, then calling GetHashCode() on each of them must yield the same result. If this is not the case, many collections won't handle class instances correctly.</value>
  </data>
  <data name="S1206_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1206_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1206_RemediationCost" xml:space="preserve">
    <value>15 min</value>
  </data>
  <data name="S1206_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1206_Tags" xml:space="preserve">
    <value>cwe,bug,cert</value>
  </data>
  <data name="S1206_Title" xml:space="preserve">
    <value>"Equals(Object)" and "GetHashCode()" should be overridden in pairs</value>
  </data>
  <data name="S121_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S121_Description" xml:space="preserve">
    <value>While not technically incorrect, the omission of curly braces can be misleading, and may lead to the introduction of errors during maintenance.</value>
  </data>
  <data name="S121_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S121_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S121_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S121_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S121_Tags" xml:space="preserve">
    <value>misra,cert,pitfall</value>
  </data>
  <data name="S121_Title" xml:space="preserve">
    <value>Control structures should use curly braces</value>
  </data>
  <data name="S1210_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S1210_Description" xml:space="preserve">
    <value>When you implement IComparable or IComparable&amp;lt;T&amp;gt; on a class you should also override Equals(object) and overload the comparison operators (==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=). That's because the CLR cannot automatically call your CompareTo implementation from Equals(object) or from the base comparison operator implementations. Additionally, it is best practice to override GetHashCode along with Equals.</value>
  </data>
  <data name="S1210_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1210_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1210_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S1210_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1210_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S1210_Title" xml:space="preserve">
    <value>"Equals" and the comparison operators should be overridden when implementing "IComparable"</value>
  </data>
  <data name="S1215_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1215_Description" xml:space="preserve">
    <value>Calling GC.Collect is rarely necessary, and can significantly affect application performance. That's because it triggers a blocking operation that examines every object in memory for cleanup. Further, you don't have control over when this blocking cleanup will actually run.</value>
  </data>
  <data name="S1215_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1215_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1215_RemediationCost" xml:space="preserve">
    <value>30min</value>
  </data>
  <data name="S1215_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S1215_Tags" xml:space="preserve">
    <value>performance,unpredictable,bad-practice</value>
  </data>
  <data name="S1215_Title" xml:space="preserve">
    <value>"GC.Collect" should not be called</value>
  </data>
  <data name="S122_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S122_Description" xml:space="preserve">
    <value>For better readability, do not put more than one statement on a single line.</value>
  </data>
  <data name="S122_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S122_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S122_RemediationCost" xml:space="preserve">
    <value>1min</value>
  </data>
  <data name="S122_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S122_Tags" xml:space="preserve">
    <value>style</value>
  </data>
  <data name="S122_Title" xml:space="preserve">
    <value>Statements should be on separate lines</value>
  </data>
  <data name="S1226_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1226_Description" xml:space="preserve">
    <value>While it is technically correct to assign to parameters from within method bodies, it is better to use temporary variables to store intermediate results.</value>
  </data>
  <data name="S1226_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1226_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1226_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1226_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1226_Tags" xml:space="preserve">
    <value>misra,pitfall</value>
  </data>
  <data name="S1226_Title" xml:space="preserve">
    <value>Method parameters and caught exceptions should not be reassigned</value>
  </data>
  <data name="S1227_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1227_Description" xml:space="preserve">
    <value>break; is an unstructured control flow statement which makes code harder to read.</value>
  </data>
  <data name="S1227_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1227_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1227_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S1227_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1227_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S1227_Title" xml:space="preserve">
    <value>break statements should not be used except for switch cases</value>
  </data>
  <data name="S1244_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S1244_Description" xml:space="preserve">
    <value>Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is not associative; push a float or a double through a series of simple mathematical operations and the answer will be different based on the order of those operation because of the rounding that takes place at each step.</value>
  </data>
  <data name="S1244_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1244_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1244_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1244_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1244_Tags" xml:space="preserve">
    <value>bug,misra</value>
  </data>
  <data name="S1244_Title" xml:space="preserve">
    <value>Floating point numbers should not be tested for equality</value>
  </data>
  <data name="S125_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S125_Description" xml:space="preserve">
    <value>Programmers should not comment out code as it bloats programs and reduces readability.</value>
  </data>
  <data name="S125_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S125_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S125_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S125_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S125_Tags" xml:space="preserve">
    <value>misra,unused</value>
  </data>
  <data name="S125_Title" xml:space="preserve">
    <value>Sections of code should not be "commented out"</value>
  </data>
  <data name="S126_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S126_Description" xml:space="preserve">
    <value>This rule applies whenever an if statement is followed by one or more else if statements; the final else if should be followed by an else statement.</value>
  </data>
  <data name="S126_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S126_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S126_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S126_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S126_Tags" xml:space="preserve">
    <value>misra,cert</value>
  </data>
  <data name="S126_Title" xml:space="preserve">
    <value>"if ... else if" constructs should end with "else" clauses</value>
  </data>
  <data name="S127_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S127_Description" xml:space="preserve">
    <value>A for loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and ending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins. </value>
  </data>
  <data name="S127_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S127_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S127_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S127_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S127_Tags" xml:space="preserve">
    <value>misra,pitfall</value>
  </data>
  <data name="S127_Title" xml:space="preserve">
    <value>"for" loop stop conditions should be invariant</value>
  </data>
  <data name="S1301_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1301_Description" xml:space="preserve">
    <value>switch statements are useful when there are many different cases depending on the value of the same expression.</value>
  </data>
  <data name="S1301_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1301_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1301_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1301_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1301_Tags" xml:space="preserve">
    <value>misra,bad-practice</value>
  </data>
  <data name="S1301_Title" xml:space="preserve">
    <value>"switch" statements should have at least 3 "case" clauses</value>
  </data>
  <data name="S1309_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1309_Description" xml:space="preserve">
    <value>This rule allows you to track the usage of the SuppressMessage attributes and #pragma warning disable mechanism.</value>
  </data>
  <data name="S1309_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1309_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1309_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S1309_Severity" xml:space="preserve">
    <value>Info</value>
  </data>
  <data name="S1309_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S1309_Title" xml:space="preserve">
    <value>Track uses of in-source issue suppressions</value>
  </data>
  <data name="S131_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S131_Description" xml:space="preserve">
    <value>The requirement for a final default clause is defensive programming. The clause should either take appropriate action, or contain a suitable comment as to why no action is taken. Even when the switch covers all current values of an enum, a default case should still be used because there is no guarantee that the enum won't be extended.</value>
  </data>
  <data name="S131_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S131_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S131_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S131_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S131_Tags" xml:space="preserve">
    <value>cwe,misra,cert</value>
  </data>
  <data name="S131_Title" xml:space="preserve">
    <value>"switch/Select" statements should end with "default/Case Else" clauses</value>
  </data>
  <data name="S1313_Category" xml:space="preserve">
    <value>Sonar Vulnerability</value>
  </data>
  <data name="S1313_Description" xml:space="preserve">
    <value>Hardcoding an IP address into source code is a bad idea for several reasons:</value>
  </data>
  <data name="S1313_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1313_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1313_RemediationCost" xml:space="preserve">
    <value>30min</value>
  </data>
  <data name="S1313_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1313_Tags" xml:space="preserve">
    <value>security,cert</value>
  </data>
  <data name="S1313_Title" xml:space="preserve">
    <value>IP addresses should not be hardcoded</value>
  </data>
  <data name="S134_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S134_Description" xml:space="preserve">
    <value>Nested if, switch, for, foreach, while, do, and try statements are key ingredients for making what's known as "Spaghetti code".</value>
  </data>
  <data name="S134_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S134_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S134_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S134_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S134_Tags" xml:space="preserve">
    <value>brain-overload</value>
  </data>
  <data name="S134_Title" xml:space="preserve">
    <value>Control flow statements "if", "switch", "for", "foreach", "while", "do"  and "try" should not be nested too deeply</value>
  </data>
  <data name="S1449_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S1449_Description" xml:space="preserve">
    <value>string.ToLower(), ToUpper, IndexOf, LastIndexOf, and Compare are all culture-dependent, as are some (floating point number and DateTime-related) calls to ToString. Fortunately, all have variants which accept an argument specifying the culture or formatter to use. Leave that argument off and the call will use the system default culture, possibly creating problems with international characters.</value>
  </data>
  <data name="S1449_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1449_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1449_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1449_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1449_Tags" xml:space="preserve">
    <value>bug,unpredictable,cert</value>
  </data>
  <data name="S1449_Title" xml:space="preserve">
    <value>Culture should be specified for "string" operations</value>
  </data>
  <data name="S1450_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1450_Description" xml:space="preserve">
    <value>When the value of a private field is always assigned to in a class' methods before being read, then it is not being used to store class information. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding.</value>
  </data>
  <data name="S1450_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1450_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1450_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1450_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1450_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S1450_Title" xml:space="preserve">
    <value>Private fields only used as local variables in methods should become local variables</value>
  </data>
  <data name="S1451_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1451_Description" xml:space="preserve">
    <value>Each source file should start with a header stating file ownership and the license which must be used to distribute the application. </value>
  </data>
  <data name="S1451_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1451_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1451_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1451_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S1451_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S1451_Title" xml:space="preserve">
    <value>Track lack of copyright and license headers</value>
  </data>
  <data name="S1479_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1479_Description" xml:space="preserve">
    <value>When switch statements have large sets of case clauses, it is usually an attempt to map two sets of data. A real map structure would be more readable and maintainable, and should be used instead.</value>
  </data>
  <data name="S1479_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1479_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1479_RemediationCost" xml:space="preserve">
    <value>30min</value>
  </data>
  <data name="S1479_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1479_Tags" xml:space="preserve">
    <value>brain-overload</value>
  </data>
  <data name="S1479_Title" xml:space="preserve">
    <value>"switch" statements should not have too many "case" clauses</value>
  </data>
  <data name="S1481_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1481_Description" xml:space="preserve">
    <value>If a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will not wonder what the variable is used for.</value>
  </data>
  <data name="S1481_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1481_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1481_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1481_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1481_Tags" xml:space="preserve">
    <value>unused</value>
  </data>
  <data name="S1481_Title" xml:space="preserve">
    <value>Unused local variables should be removed</value>
  </data>
  <data name="S1541_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1541_Description" xml:space="preserve">
    <value>The cyclomatic complexity of methods and properties should not exceed a defined threshold. Complex code can perform poorly and will in any case be difficult to understand and therefore to maintain.</value>
  </data>
  <data name="S1541_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1541_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1541_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S1541_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S1541_Tags" xml:space="preserve">
    <value>brain-overload</value>
  </data>
  <data name="S1541_Title" xml:space="preserve">
    <value>Methods and properties should not be too complex</value>
  </data>
  <data name="S1643_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1643_Description" xml:space="preserve">
    <value>StringBuilder is more efficient than string concatenation, especially when the operator is repeated over and over as in loops.</value>
  </data>
  <data name="S1643_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1643_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1643_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S1643_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1643_Tags" xml:space="preserve">
    <value>performance</value>
  </data>
  <data name="S1643_Title" xml:space="preserve">
    <value>Strings should not be concatenated using '+' in a loop</value>
  </data>
  <data name="S1656_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S1656_Description" xml:space="preserve">
    <value>There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake and some other value or variable was intended for the assignment instead.</value>
  </data>
  <data name="S1656_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1656_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1656_RemediationCost" xml:space="preserve">
    <value>3min</value>
  </data>
  <data name="S1656_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1656_Tags" xml:space="preserve">
    <value>cert</value>
  </data>
  <data name="S1656_Title" xml:space="preserve">
    <value>Variables should not be self-assigned</value>
  </data>
  <data name="S1659_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1659_Description" xml:space="preserve">
    <value>Declaring multiple variable on one line is difficult to read.</value>
  </data>
  <data name="S1659_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1659_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1659_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S1659_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1659_Tags" xml:space="preserve">
    <value>convention,misra,cert</value>
  </data>
  <data name="S1659_Title" xml:space="preserve">
    <value>Multiple variables should not be declared on the same line</value>
  </data>
  <data name="S1694_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1694_Description" xml:space="preserve">
    <value>The purpose of an abstract class is to provide some heritable behaviors while also defining methods which must be implemented by sub-classes.</value>
  </data>
  <data name="S1694_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1694_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1694_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1694_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1694_Tags" xml:space="preserve">
    <value>convention</value>
  </data>
  <data name="S1694_Title" xml:space="preserve">
    <value>An abstract class should have both abstract and concrete methods</value>
  </data>
  <data name="S1697_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S1697_Description" xml:space="preserve">
    <value>When either the equality operator in a null test or the logical operator that follows it is reversed, the code has the appearance of safely null-testing the object before dereferencing it. Unfortunately the effect is just the opposite - the object is null-tested and then dereferenced only if it is null, leading to a guaranteed null pointer dereference.</value>
  </data>
  <data name="S1697_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1697_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1697_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S1697_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1697_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S1697_Title" xml:space="preserve">
    <value>Short-circuit logic should be used to prevent null pointer dereferences in conditionals</value>
  </data>
  <data name="S1698_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1698_Description" xml:space="preserve">
    <value>Using the equality == and inequality != operators to compare two objects generally works. The operators can be overloaded, and therefore the comparison can resolve to the appropriate method. However, when the operators are used on interface instances, then == resolves to reference equality, which may result in unexpected behavior if implementing classes override Equals. Similarly, when a class overrides Equals, but instances are compared with non-overloaded ==, there is a high chance that value comparison was meant instead of the reference one.</value>
  </data>
  <data name="S1698_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1698_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1698_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S1698_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1698_Tags" xml:space="preserve">
    <value>cwe,cert,suspicious</value>
  </data>
  <data name="S1698_Title" xml:space="preserve">
    <value>"==" should not be used when "Equals" is overridden</value>
  </data>
  <data name="S1699_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1699_Description" xml:space="preserve">
    <value>Calling an overridable method from a constructor could result in failures or strange behaviors when instantiating a subclass which overrides the method.</value>
  </data>
  <data name="S1699_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1699_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1699_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S1699_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S1699_Tags" xml:space="preserve">
    <value>cert,pitfall</value>
  </data>
  <data name="S1699_Title" xml:space="preserve">
    <value>Constructors should only call non-overridable methods</value>
  </data>
  <data name="S1751_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S1751_Description" xml:space="preserve">
    <value>Having an unconditional break, return, (@)throw or goto in a loop renders it useless; the loop will only execute once and the loop structure itself is simply wasted keystrokes.</value>
  </data>
  <data name="S1751_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1751_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1751_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1751_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1751_Tags" xml:space="preserve">
    <value>bug,misra,cert,unused</value>
  </data>
  <data name="S1751_Title" xml:space="preserve">
    <value>Jump statements should not be used unconditionally</value>
  </data>
  <data name="S1764_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S1764_Description" xml:space="preserve">
    <value>Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste error and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical operators, having the same value on both sides of an operator yields predictable results, and should be simplified.</value>
  </data>
  <data name="S1764_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1764_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1764_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S1764_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1764_Tags" xml:space="preserve">
    <value>bug,cert</value>
  </data>
  <data name="S1764_Title" xml:space="preserve">
    <value>Identical expressions should not be used on both sides of a binary operator</value>
  </data>
  <data name="S1848_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S1848_Description" xml:space="preserve">
    <value>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could lead to an unexpected behavior in production.</value>
  </data>
  <data name="S1848_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1848_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1848_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1848_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1848_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S1848_Title" xml:space="preserve">
    <value>Objects should not be created to be dropped immediately without being used</value>
  </data>
  <data name="S1854_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S1854_Description" xml:space="preserve">
    <value>A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value only to then overwrite it or throw it away, could indicate a serious error in the code. Even if it's not an error, it is at best a waste of resources. Therefore all calculated values should be used.</value>
  </data>
  <data name="S1854_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1854_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1854_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S1854_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1854_Tags" xml:space="preserve">
    <value>cwe,bug,cert,unused</value>
  </data>
  <data name="S1854_Title" xml:space="preserve">
    <value>Dead stores should be removed</value>
  </data>
  <data name="S1858_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1858_Description" xml:space="preserve">
    <value>Invoking a method designed to return a string representation of an object which is already a string is a waste of keystrokes. Similarly, explicitly invoking ToString() when the compiler would do it implicitly is also needless code-bloat.</value>
  </data>
  <data name="S1858_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1858_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1858_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S1858_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1858_Tags" xml:space="preserve">
    <value>finding,clumsy</value>
  </data>
  <data name="S1858_Title" xml:space="preserve">
    <value>"ToString()" calls should not be redundant</value>
  </data>
  <data name="S1862_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S1862_Description" xml:space="preserve">
    <value>A chain of if/else if statements is evaluated from top to bottom. At most, only one branch will be executed: the first one with a condition that evaluates to true. </value>
  </data>
  <data name="S1862_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1862_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1862_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S1862_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1862_Tags" xml:space="preserve">
    <value>bug,cert,unused,pitfall</value>
  </data>
  <data name="S1862_Title" xml:space="preserve">
    <value>Related "if/else if" statements should not have the same condition</value>
  </data>
  <data name="S1871_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1871_Description" xml:space="preserve">
    <value>Having two cases in the same switch statement or branches in the same if structure with the same implementation is at best duplicate code, and at worst a coding error. If the same logic is truly needed for both instances, then in an if structure they should be combined, or for a switch, one should fall through to the other.</value>
  </data>
  <data name="S1871_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1871_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1871_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S1871_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S1871_Tags" xml:space="preserve">
    <value>design,suspicious</value>
  </data>
  <data name="S1871_Title" xml:space="preserve">
    <value>Two branches in a conditional structure should not have exactly the same implementation</value>
  </data>
  <data name="S1905_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1905_Description" xml:space="preserve">
    <value>Unnecessary casting expressions make the code harder to read and understand.</value>
  </data>
  <data name="S1905_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1905_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1905_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S1905_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1905_Tags" xml:space="preserve">
    <value>redundant,clumsy</value>
  </data>
  <data name="S1905_Title" xml:space="preserve">
    <value>Redundant casts should not be used</value>
  </data>
  <data name="S1939_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1939_Description" xml:space="preserve">
    <value>An inheritance list entry is redundant if:</value>
  </data>
  <data name="S1939_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1939_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1939_RemediationCost" xml:space="preserve">
    <value>1min</value>
  </data>
  <data name="S1939_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1939_Tags" xml:space="preserve">
    <value>clumsy</value>
  </data>
  <data name="S1939_Title" xml:space="preserve">
    <value>Inheritance list should not be redundant</value>
  </data>
  <data name="S1940_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1940_Description" xml:space="preserve">
    <value>It is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead.</value>
  </data>
  <data name="S1940_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1940_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1940_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S1940_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S1940_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S1940_Title" xml:space="preserve">
    <value>Boolean checks should not be inverted</value>
  </data>
  <data name="S1944_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S1944_Description" xml:space="preserve">
    <value>Inappropriate casts are issues that will lead to unexpected behavior or runtime errors, such as InvalidCastExceptions. The compiler will catch bad casts from one class to another, but not bad casts to interfaces. Nor will it catch nullable values that are known to be null but that are cast to their underlying value types anyway.</value>
  </data>
  <data name="S1944_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S1944_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1944_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S1944_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S1944_Tags" xml:space="preserve">
    <value>cwe,bug,misra,cert,pitfall</value>
  </data>
  <data name="S1944_Title" xml:space="preserve">
    <value>Inappropriate casts should not be made</value>
  </data>
  <data name="S1994_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S1994_Description" xml:space="preserve">
    <value>It can be extremely confusing when a for loop's counter is incremented outside of its increment clause. In such cases, the increment should be moved to the loop's increment clause if at all possible.</value>
  </data>
  <data name="S1994_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S1994_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S1994_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S1994_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S1994_Tags" xml:space="preserve">
    <value>confusing</value>
  </data>
  <data name="S1994_Title" xml:space="preserve">
    <value>"for" loop increment clauses should modify the loops' counters</value>
  </data>
  <data name="S2070_Category" xml:space="preserve">
    <value>Sonar Vulnerability</value>
  </data>
  <data name="S2070_Description" xml:space="preserve">
    <value>The MD5 algorithm and its successor, SHA-1, are no longer considered secure, because it is too easy to create hash collisions with them. That is, it takes too little computational effort to come up with a different input that produces the same MD5 or SHA-1 hash, and using the new, same-hash value gives an attacker the same access as if he had the originally-hashed value. This applies as well to the other Message-Digest algorithms: MD2, MD4, MD6.</value>
  </data>
  <data name="S2070_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2070_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2070_RemediationCost" xml:space="preserve">
    <value>30min</value>
  </data>
  <data name="S2070_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S2070_Tags" xml:space="preserve">
    <value>cwe,security,owasp-a6,sans-top25-porous</value>
  </data>
  <data name="S2070_Title" xml:space="preserve">
    <value>SHA-1 and Message-Digest hash algorithms should not be used</value>
  </data>
  <data name="S2123_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2123_Description" xml:space="preserve">
    <value>A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.</value>
  </data>
  <data name="S2123_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2123_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2123_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2123_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2123_Tags" xml:space="preserve">
    <value>bug,unused</value>
  </data>
  <data name="S2123_Title" xml:space="preserve">
    <value>Values should not be uselessly incremented</value>
  </data>
  <data name="S2156_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2156_Description" xml:space="preserve">
    <value>The difference between private and protected visibility is that child classes can see and use protected members, but they cannot see private ones. Since a sealed class cannot have children, marking its members protected is confusingly pointless.</value>
  </data>
  <data name="S2156_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2156_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2156_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2156_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2156_Tags" xml:space="preserve">
    <value>confusing</value>
  </data>
  <data name="S2156_Title" xml:space="preserve">
    <value>"sealed" classes should not have "protected" members</value>
  </data>
  <data name="S2178_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2178_Description" xml:space="preserve">
    <value>The use of non-short-circuit logic in a boolean context is likely a mistake - one that could cause serious program errors as conditions are evaluated under the wrong circumstances.</value>
  </data>
  <data name="S2178_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2178_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2178_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2178_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S2178_Tags" xml:space="preserve">
    <value>cert</value>
  </data>
  <data name="S2178_Title" xml:space="preserve">
    <value>Short-circuit logic should be used in boolean contexts</value>
  </data>
  <data name="S2184_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2184_Description" xml:space="preserve">
    <value>When division is performed on ints, the result will always be an int. You can assign that result to a double, float or decimal with automatic type conversion, but having started as an int, the result will likely not be what you expect. If the result of int division is assigned to a floating-point variable, precision will have been lost before the assignment. Instead, at least one operand should be cast or promoted to the final type before the operation takes place.</value>
  </data>
  <data name="S2184_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2184_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2184_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S2184_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2184_Tags" xml:space="preserve">
    <value>cwe,overflow,bug,sans-top25-risky,misra,cert</value>
  </data>
  <data name="S2184_Title" xml:space="preserve">
    <value>Results of integer division should not be assigned to floating point variables</value>
  </data>
  <data name="S2190_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2190_Description" xml:space="preserve">
    <value>Recursion happens when control enters a loop that has no exit. This can happen a method invokes itself, when a pair of methods invoke each other, or when gotos are used to move between two segments of code. It can be a useful tool, but unless the method includes a provision to break out of the recursion and return, the recursion will continue until the stack overflows and the program crashes.</value>
  </data>
  <data name="S2190_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2190_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2190_RemediationCost" xml:space="preserve">
    <value>30min</value>
  </data>
  <data name="S2190_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S2190_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S2190_Title" xml:space="preserve">
    <value>Recursion should not be infinite</value>
  </data>
  <data name="S2197_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2197_Description" xml:space="preserve">
    <value>When the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the modulus of a variable for equality with a positive number (or a negative one) could result in unexpected results. </value>
  </data>
  <data name="S2197_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2197_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2197_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2197_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S2197_Tags" xml:space="preserve">
    <value>cert,suspicious</value>
  </data>
  <data name="S2197_Title" xml:space="preserve">
    <value>Modulus results should not be checked for direct equality</value>
  </data>
  <data name="S2201_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2201_Description" xml:space="preserve">
    <value>When the call to a function doesn't have any side effects, what is the point of making the call if the results are ignored? In such case, either the function call is useless and should be dropped or the source code doesn't behave as expected.</value>
  </data>
  <data name="S2201_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2201_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2201_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S2201_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2201_Tags" xml:space="preserve">
    <value>bug,misra,cert</value>
  </data>
  <data name="S2201_Title" xml:space="preserve">
    <value>Return values should not be ignored when function calls don't have any side effects</value>
  </data>
  <data name="S2219_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2219_Description" xml:space="preserve">
    <value>To check the type of an object there are several options:</value>
  </data>
  <data name="S2219_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2219_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2219_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2219_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2219_Tags" xml:space="preserve">
    <value>clumsy</value>
  </data>
  <data name="S2219_Title" xml:space="preserve">
    <value>Runtime type checking should be simplified</value>
  </data>
  <data name="S2223_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2223_Description" xml:space="preserve">
    <value>A static field that is neither constant nor read-only is not thread-safe. Correctly accessing these fields from different threads needs synchronization with locks. Improper synchronization may lead to unexpected results, thus publicly visible static fields are best suited for storing non-changing data shared by many consumers. To enforce this intent, these fields should be marked readonly or converted to constants.</value>
  </data>
  <data name="S2223_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2223_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2223_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S2223_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S2223_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S2223_Title" xml:space="preserve">
    <value>Non-constant static fields should not be visible</value>
  </data>
  <data name="S2225_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2225_Description" xml:space="preserve">
    <value>Calling ToString() on an object should always return a string. Returning null instead contravenes the method's implicit contract.</value>
  </data>
  <data name="S2225_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2225_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2225_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2225_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2225_Tags" xml:space="preserve">
    <value>cwe,bug</value>
  </data>
  <data name="S2225_Title" xml:space="preserve">
    <value>"ToString()" method should not return null</value>
  </data>
  <data name="S2228_Category" xml:space="preserve">
    <value>Sonar Vulnerability</value>
  </data>
  <data name="S2228_Description" xml:space="preserve">
    <value>Debug statements are always useful during development. But include them in production code - particularly in code that runs client-side - and you run the risk of inadvertently exposing sensitive information.</value>
  </data>
  <data name="S2228_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2228_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2228_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2228_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2228_Tags" xml:space="preserve">
    <value>security,owasp-a6</value>
  </data>
  <data name="S2228_Title" xml:space="preserve">
    <value>Console logging should not be used</value>
  </data>
  <data name="S2234_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2234_Description" xml:space="preserve">
    <value>When the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when the names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead to unexpected results.</value>
  </data>
  <data name="S2234_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2234_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2234_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2234_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2234_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S2234_Title" xml:space="preserve">
    <value>Parameters should be passed in the correct order</value>
  </data>
  <data name="S2259_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2259_Description" xml:space="preserve">
    <value>A reference to null should never be dereferenced/accessed. Doing so will cause a NullReferenceException to be thrown. At best, such an exception will cause abrupt program termination. At worst, it could expose debugging information that would be useful to an attacker, or it could allow an attacker to bypass security measures.</value>
  </data>
  <data name="S2259_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2259_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2259_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S2259_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2259_Tags" xml:space="preserve">
    <value>cwe,bug,cert</value>
  </data>
  <data name="S2259_Title" xml:space="preserve">
    <value>Null pointers should not be dereferenced</value>
  </data>
  <data name="S2275_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2275_Description" xml:space="preserve">
    <value>Because composite format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to unexpected behaviors or runtime errors. This rule statically validates the good behavior of composite formats when calling the methods of String.Format, StringBuilder.AppendFormat, Console.Write, Console.WriteLine, TextWriter.Write, TextWriter.WriteLine, Debug.WriteLine(String, Object[]), Trace.TraceError(String, Object[]), Trace.TraceInformation(String, Object[]), Trace.TraceWarning(String, Object[]) and TraceSource.TraceInformation(String, Object[]). </value>
  </data>
  <data name="S2275_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2275_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2275_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S2275_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S2275_Tags" xml:space="preserve">
    <value>bug,cert,pitfall</value>
  </data>
  <data name="S2275_Title" xml:space="preserve">
    <value>Composite format strings should not lead to unexpected behavior at runtime</value>
  </data>
  <data name="S2278_Category" xml:space="preserve">
    <value>Sonar Vulnerability</value>
  </data>
  <data name="S2278_Description" xml:space="preserve">
    <value>According to the US National Institute of Standards and Technology (NIST), the Data Encryption Standard (DES) is no longer considered secure:</value>
  </data>
  <data name="S2278_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2278_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2278_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S2278_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S2278_Tags" xml:space="preserve">
    <value>cwe,security,cert,owasp-a6,sans-top25-porous</value>
  </data>
  <data name="S2278_Title" xml:space="preserve">
    <value>Neither DES (Data Encryption Standard) nor DESede (3DES) should be used</value>
  </data>
  <data name="S2290_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2290_Description" xml:space="preserve">
    <value>Field-like events are events that do not have explicit add and remove methods. The compiler generates a private delegate field to back the event, as well as generating the implicit add and remove methods.</value>
  </data>
  <data name="S2290_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2290_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2290_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S2290_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S2290_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S2290_Title" xml:space="preserve">
    <value>Field-like events should not be virtual</value>
  </data>
  <data name="S2291_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2291_Description" xml:space="preserve">
    <value>Enumerable.Sum() always executes addition in a checked context, so an OverflowException will be thrown if the value exceeds MaxValue even if an unchecked context was specified. Using an unchecked context anyway represents a misunderstanding of how Sum works.</value>
  </data>
  <data name="S2291_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2291_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2291_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S2291_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S2291_Tags" xml:space="preserve">
    <value>error-handling,bug</value>
  </data>
  <data name="S2291_Title" xml:space="preserve">
    <value>Overflow checking should not be disabled for "Enumerable.Sum"</value>
  </data>
  <data name="S2292_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2292_Description" xml:space="preserve">
    <value>Trivial properties, which include no logic but setting and getting a backing field should be converted to auto-implemented properties, yielding cleaner and more readable code.</value>
  </data>
  <data name="S2292_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2292_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2292_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2292_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2292_Tags" xml:space="preserve">
    <value>clumsy</value>
  </data>
  <data name="S2292_Title" xml:space="preserve">
    <value>Trivial properties should be auto-implemented</value>
  </data>
  <data name="S2306_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2306_Description" xml:space="preserve">
    <value>Since C# 5.0, async and await are contextual keywords. Contextual keywords do have a particular meaning in some contexts, but can still be used as variable names. Keywords, on the other hand, are always reserved, and therefore are not valid variable names. To avoid any confusion though, it is best to not use async and await as identifiers.</value>
  </data>
  <data name="S2306_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2306_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2306_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2306_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S2306_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S2306_Title" xml:space="preserve">
    <value>"async" and "await" should not be used as identifiers</value>
  </data>
  <data name="S2325_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2325_Description" xml:space="preserve">
    <value>Class methods and properties that don't access instance data can be static to prevent any misunderstanding about the contract of the method. </value>
  </data>
  <data name="S2325_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2325_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2325_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2325_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2325_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S2325_Title" xml:space="preserve">
    <value>Methods and properties that don't access instance data should be static</value>
  </data>
  <data name="S2326_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2326_Description" xml:space="preserve">
    <value>Type parameters that aren't used are dead code, which can only distract and possibly confuse developers during maintenance. Therefore, unused type parameters should be removed.</value>
  </data>
  <data name="S2326_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2326_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2326_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2326_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2326_Tags" xml:space="preserve">
    <value>cert,unused</value>
  </data>
  <data name="S2326_Title" xml:space="preserve">
    <value>Unused type parameters should be removed</value>
  </data>
  <data name="S2328_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2328_Description" xml:space="preserve">
    <value>GetHashCode is used to file an object in a Dictionary or Hashtable. If GetHashCode uses non-readonly fields and those fields change after the object is stored, the object immediately becomes mis-filed in the Hashtable. Any subsequent test to see if the object is in the Hashtable will return a false negative.</value>
  </data>
  <data name="S2328_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2328_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2328_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S2328_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2328_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S2328_Title" xml:space="preserve">
    <value>"GetHashCode" should not reference mutable fields</value>
  </data>
  <data name="S2330_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2330_Description" xml:space="preserve">
    <value>Array covariance is the principle that if an implicit or explicit reference conversion exits from type A to B, then the same conversion exists from the array type A[] to B[].</value>
  </data>
  <data name="S2330_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2330_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2330_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S2330_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S2330_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S2330_Title" xml:space="preserve">
    <value>Array covariance should not be used</value>
  </data>
  <data name="S2333_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2333_Description" xml:space="preserve">
    <value>Unnecessary keywords simply clutter the code and should be removed. Specifically:</value>
  </data>
  <data name="S2333_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2333_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2333_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S2333_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2333_Tags" xml:space="preserve">
    <value>unused,finding,clumsy</value>
  </data>
  <data name="S2333_Title" xml:space="preserve">
    <value>Redundant modifiers should not be used</value>
  </data>
  <data name="S2339_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2339_Description" xml:space="preserve">
    <value>Constant members are copied at compile time to the call sites, instead of being fetched at runtime.</value>
  </data>
  <data name="S2339_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2339_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2339_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2339_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S2339_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S2339_Title" xml:space="preserve">
    <value>Public constant members should not be used</value>
  </data>
  <data name="S2342_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2342_Description" xml:space="preserve">
    <value>Shared naming conventions allow teams to collaborate efficiently. This rule checks that all enum names match a provided regular expression.</value>
  </data>
  <data name="S2342_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2342_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2342_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2342_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2342_Tags" xml:space="preserve">
    <value>convention</value>
  </data>
  <data name="S2342_Title" xml:space="preserve">
    <value>Enumeration types should comply with a naming convention</value>
  </data>
  <data name="S2344_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2344_Description" xml:space="preserve">
    <value>The information that an enumeration type is actually an enumeration or a set of flags should not be duplicated in its name.</value>
  </data>
  <data name="S2344_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2344_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2344_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2344_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2344_Tags" xml:space="preserve">
    <value>convention</value>
  </data>
  <data name="S2344_Title" xml:space="preserve">
    <value>Enumeration type names should not have "Flags" or "Enum" suffixes</value>
  </data>
  <data name="S2345_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2345_Description" xml:space="preserve">
    <value>Flags enumerations should not rely on the language to initialize the values of their members. Implicit initialization will set the first member to 0, and increment the value by one for each subsequent member. This implicit behavior does not allow members to be combined using the bitwise or operator in a useful way.</value>
  </data>
  <data name="S2345_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2345_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2345_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2345_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2345_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S2345_Title" xml:space="preserve">
    <value>Flags enumerations should explicitly initialize all their members</value>
  </data>
  <data name="S2346_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2346_Description" xml:space="preserve">
    <value>Consisitent use of "None" in flags enumerations indicates that all flag values are cleared. The value 0 should not be used to indicate any other state, since there is no way to check that the bit 0 is set.</value>
  </data>
  <data name="S2346_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2346_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2346_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2346_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S2346_Tags" xml:space="preserve">
    <value>convention</value>
  </data>
  <data name="S2346_Title" xml:space="preserve">
    <value>Flags enumerations zero-value members should be named "None"</value>
  </data>
  <data name="S2357_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2357_Description" xml:space="preserve">
    <value>Fields should not be part of an API, and therefore should always be private. Indeed, they cannot be added to an interface for instance, and validation cannot be added later on without breaking backward compatiblity. Instead, developers should encapsulate their fields into properties. Explicit property getters and setters can be introduced for validation purposes or to smooth the transition to a newer system.</value>
  </data>
  <data name="S2357_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2357_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2357_RemediationCost" xml:space="preserve">
    <value>30min</value>
  </data>
  <data name="S2357_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2357_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S2357_Title" xml:space="preserve">
    <value>Fields should be private</value>
  </data>
  <data name="S2360_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2360_Description" xml:space="preserve">
    <value>The overloading mechanism should be used in place of optional parameters for several reasons:</value>
  </data>
  <data name="S2360_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2360_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2360_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2360_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S2360_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S2360_Title" xml:space="preserve">
    <value>Optional parameters should not be used</value>
  </data>
  <data name="S2365_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2365_Description" xml:space="preserve">
    <value>Most developers expect property access to be as efficient as field access. However, if a property returns a copy of an array or collection, it will be much slower than a simple field access, contrary to the caller's likely expectations. Therefore, such properties should be refactored into methods so that callers are not surprised by unexpectedly poor performance.</value>
  </data>
  <data name="S2365_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2365_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2365_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2365_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S2365_Tags" xml:space="preserve">
    <value>api-design,performance</value>
  </data>
  <data name="S2365_Title" xml:space="preserve">
    <value>Properties should not make collection or array copies</value>
  </data>
  <data name="S2368_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2368_Description" xml:space="preserve">
    <value>Exposing methods with multidimensional array parameters requires developers to have advanced knowledge about the language in order to be able to use them. Moreover, what exactly to pass to such parameters is not intuitive. Therefore, such methods should not be exposed, but can be used internally.</value>
  </data>
  <data name="S2368_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2368_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2368_RemediationCost" xml:space="preserve">
    <value>1h</value>
  </data>
  <data name="S2368_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S2368_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S2368_Title" xml:space="preserve">
    <value>Public methods should not have multidimensional array parameters</value>
  </data>
  <data name="S2372_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2372_Description" xml:space="preserve">
    <value>Property getters should be simple operations that are always safe to call. If exceptions need to be thrown, it is best to convert the property to a method. </value>
  </data>
  <data name="S2372_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2372_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2372_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S2372_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2372_Tags" xml:space="preserve">
    <value>error-handling</value>
  </data>
  <data name="S2372_Title" xml:space="preserve">
    <value>Exceptions should not be thrown from property getters</value>
  </data>
  <data name="S2376_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2376_Description" xml:space="preserve">
    <value>Properties with only setters are confusing and counterintuitive. Instead, a property getter should be added if possible, or the property should be replaced with a setter method.</value>
  </data>
  <data name="S2376_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2376_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2376_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S2376_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2376_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S2376_Title" xml:space="preserve">
    <value>Write-only properties should not be used</value>
  </data>
  <data name="S2386_Category" xml:space="preserve">
    <value>Sonar Vulnerability</value>
  </data>
  <data name="S2386_Description" xml:space="preserve">
    <value>public static mutable fields of classes which are accessed directly should be protected to the degree possible. This can be done by reducing the accessibility of the field or by changing the return type to an immutable type.</value>
  </data>
  <data name="S2386_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2386_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2386_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S2386_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2386_Tags" xml:space="preserve">
    <value>cwe,security,unpredictable,cert</value>
  </data>
  <data name="S2386_Title" xml:space="preserve">
    <value>Mutable fields should not be "public static"</value>
  </data>
  <data name="S2387_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2387_Description" xml:space="preserve">
    <value>Having a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy and you'll get confusion at best, chaos at worst. Perhaps even worse is the case where a child class field varies from the name of a parent class only by case.</value>
  </data>
  <data name="S2387_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2387_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2387_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2387_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S2387_Tags" xml:space="preserve">
    <value>confusing</value>
  </data>
  <data name="S2387_Title" xml:space="preserve">
    <value>Child class fields should not shadow parent class fields</value>
  </data>
  <data name="S2436_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2436_Description" xml:space="preserve">
    <value>A method or class with too many type parameters has likely aggregated too many responsibilities and should be split.</value>
  </data>
  <data name="S2436_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2436_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2436_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S2436_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2436_Tags" xml:space="preserve">
    <value>brain-overload</value>
  </data>
  <data name="S2436_Title" xml:space="preserve">
    <value>Classes and methods should not have too many generic parameters</value>
  </data>
  <data name="S2437_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2437_Description" xml:space="preserve">
    <value>Certain bit operations are just silly and should not be performed because their results are predictable.</value>
  </data>
  <data name="S2437_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2437_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2437_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2437_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S2437_Tags" xml:space="preserve">
    <value>suspicious</value>
  </data>
  <data name="S2437_Title" xml:space="preserve">
    <value>Silly bit operations should not be performed</value>
  </data>
  <data name="S2486_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2486_Description" xml:space="preserve">
    <value>When exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly, or at least to log them.</value>
  </data>
  <data name="S2486_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2486_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2486_RemediationCost" xml:space="preserve">
    <value>1h</value>
  </data>
  <data name="S2486_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2486_Tags" xml:space="preserve">
    <value>cwe,error-handling,suspicious</value>
  </data>
  <data name="S2486_Title" xml:space="preserve">
    <value>Generic exceptions should not be ignored</value>
  </data>
  <data name="S2551_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2551_Description" xml:space="preserve">
    <value>Locking on the current object instance (i.e. this), or on a Type object increases the chance of deadlocks because any other thread could acquire (or attempt to acquire) the same lock for another unrelated purpose. </value>
  </data>
  <data name="S2551_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2551_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2551_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S2551_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S2551_Tags" xml:space="preserve">
    <value>multi-threading,bug</value>
  </data>
  <data name="S2551_Title" xml:space="preserve">
    <value>Types and "this" should not be used for locking</value>
  </data>
  <data name="S2583_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2583_Description" xml:space="preserve">
    <value>Conditional expressions which are always true or false can lead to dead code. Such code is always buggy and should never be used in production.</value>
  </data>
  <data name="S2583_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2583_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2583_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S2583_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2583_Tags" xml:space="preserve">
    <value>cwe,bug,misra,cert,unused,pitfall</value>
  </data>
  <data name="S2583_Title" xml:space="preserve">
    <value>Conditionally executed blocks should be reachable</value>
  </data>
  <data name="S2589_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2589_Description" xml:space="preserve">
    <value>If a boolean expression doesn't change the evaluation of the condition, then it is entirely unnecessary, and can be removed. If it is gratuitous because it does not match the programmer's intent, then it's a bug and the expression should be fixed.</value>
  </data>
  <data name="S2589_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2589_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2589_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S2589_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2589_Tags" xml:space="preserve">
    <value>cwe,bug,misra,cert,redundant</value>
  </data>
  <data name="S2589_Title" xml:space="preserve">
    <value>Boolean expressions should not be gratuitous</value>
  </data>
  <data name="S2674_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2674_Description" xml:space="preserve">
    <value>You cannot assume that any given stream reading call will fill the byte[] passed in to the method with the number of bytes requested. Instead, you must check the value returned by the read method to see how many bytes were read. Fail to do so, and you introduce a bug that is both harmful and difficult to reproduce.</value>
  </data>
  <data name="S2674_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2674_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2674_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S2674_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2674_Tags" xml:space="preserve">
    <value>bug,cert</value>
  </data>
  <data name="S2674_Title" xml:space="preserve">
    <value>The length returned from a stream read should be checked</value>
  </data>
  <data name="S2681_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2681_Description" xml:space="preserve">
    <value>Curly braces can be omitted from a one-line block, such as with an if statement or for loop, but doing so can be misleading and induce bugs. </value>
  </data>
  <data name="S2681_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2681_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2681_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2681_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2681_Tags" xml:space="preserve">
    <value>cwe,bug,cert</value>
  </data>
  <data name="S2681_Title" xml:space="preserve">
    <value>Multiline blocks should be enclosed in curly braces</value>
  </data>
  <data name="S2688_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2688_Description" xml:space="preserve">
    <value>NaN is not equal to anything, even itself. Testing for equality or inequality against NaN will yield predictable results, but probably not the ones you want. </value>
  </data>
  <data name="S2688_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2688_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2688_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2688_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2688_Tags" xml:space="preserve">
    <value>bug,cert</value>
  </data>
  <data name="S2688_Title" xml:space="preserve">
    <value>"NaN" should not be used in comparisons</value>
  </data>
  <data name="S2692_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2692_Description" xml:space="preserve">
    <value>Most checks against an IndexOf value compare it with -1 because 0 is a valid index. Any checks which look for values &amp;gt;0 ignore the first element, which is likely a bug. If the intent is merely to check inclusion of a value in a string, List, or an array, consider using the Contains method instead.</value>
  </data>
  <data name="S2692_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2692_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2692_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S2692_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S2692_Tags" xml:space="preserve">
    <value>suspicious</value>
  </data>
  <data name="S2692_Title" xml:space="preserve">
    <value>"IndexOf" checks should not be for positive numbers</value>
  </data>
  <data name="S2696_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2696_Description" xml:space="preserve">
    <value>Correctly updating a static field from a non-static method is tricky to get right and could easily lead to bugs if there are multiple class instances and/or multiple threads in play. </value>
  </data>
  <data name="S2696_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2696_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2696_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S2696_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S2696_Tags" xml:space="preserve">
    <value>multi-threading</value>
  </data>
  <data name="S2696_Title" xml:space="preserve">
    <value>Instance members should not write to "static" fields</value>
  </data>
  <data name="S2737_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2737_Description" xml:space="preserve">
    <value>A catch clause that only rethrows the caught exception has the same effect as omitting the catch altogether and letting it bubble up automatically, but with more code and the additional detrement of leaving maintainers scratching their heads. </value>
  </data>
  <data name="S2737_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2737_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2737_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2737_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2737_Tags" xml:space="preserve">
    <value>cert,unused,finding,clumsy</value>
  </data>
  <data name="S2737_Title" xml:space="preserve">
    <value>"catch" clauses should do more than rethrow</value>
  </data>
  <data name="S2743_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2743_Description" xml:space="preserve">
    <value>A static field in a generic type is not shared among instances of different closed constructed types, thus LengthLimitedSingletonCollection&amp;lt;int&amp;gt;.instances and LengthLimitedSingletonCollection&amp;lt;string&amp;gt;.instances will point to different objects, even though instances is seemingly shared among all LengthLimitedSingletonCollection&amp;lt;&amp;gt; generic classes.</value>
  </data>
  <data name="S2743_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2743_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2743_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S2743_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2743_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S2743_Title" xml:space="preserve">
    <value>Static fields should not be used in generic types</value>
  </data>
  <data name="S2757_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2757_Description" xml:space="preserve">
    <value>The use of operators pairs ( =+, =- or =! ) where the reversed, single operator was meant (+=, -= or !=) will compile and run, but not produce the expected results.</value>
  </data>
  <data name="S2757_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2757_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2757_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S2757_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2757_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S2757_Title" xml:space="preserve">
    <value>"=+" should not be used instead of "+="</value>
  </data>
  <data name="S2758_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2758_Description" xml:space="preserve">
    <value>When the second and third operands of a ternary operator are the same, the operator will always return the same value regardless of the condition. Either the operator itself is pointless, or a mistake was made in coding it. </value>
  </data>
  <data name="S2758_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2758_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2758_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2758_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2758_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S2758_Title" xml:space="preserve">
    <value>The ternary operator should not return the same value regardless of the condition</value>
  </data>
  <data name="S2760_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2760_Description" xml:space="preserve">
    <value>When the same condition is checked twice in a row, it is either confusing - why have separate checks? - or an error - some other condition should have been checked in the second test.</value>
  </data>
  <data name="S2760_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2760_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2760_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2760_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2760_Tags" xml:space="preserve">
    <value>suspicious,clumsy</value>
  </data>
  <data name="S2760_Title" xml:space="preserve">
    <value>Sequential tests should not check the same condition</value>
  </data>
  <data name="S2761_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2761_Description" xml:space="preserve">
    <value>Calling the ! or ~ prefix operator twice does nothing: the second invocation undoes the first. Such mistakes are typically caused by accidentally double-tapping the key in question without noticing.</value>
  </data>
  <data name="S2761_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2761_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2761_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2761_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2761_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S2761_Title" xml:space="preserve">
    <value>Doubled prefix operators "!!" and "~~" should not be used</value>
  </data>
  <data name="S2930_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2930_Description" xml:space="preserve">
    <value>When writing managed code, you don't need to worry about allocating or freeing memory: The garbage collector takes care of it. For efficiency reasons, some objects such as Bitmap use unmanaged memory, enabling for example the use of pointer arithmetic. Such objects have potentially huge unmanaged memory footprints, but will have tiny managed ones. Unfortunately, the garbage collector only sees the tiny managed footprint, and fails to reclaim the unmanaged memory (by calling Bitmap's finalizer method) in a timely fashion. </value>
  </data>
  <data name="S2930_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2930_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2930_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S2930_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S2930_Tags" xml:space="preserve">
    <value>cwe,denial-of-service,bug</value>
  </data>
  <data name="S2930_Title" xml:space="preserve">
    <value>"IDisposables" should be disposed</value>
  </data>
  <data name="S2931_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2931_Description" xml:space="preserve">
    <value>Classes with IDisposable members are responsible for cleaning up those members by calling their Dispose methods. The best practice here is for the owning class to itself implement IDisposable and call its members' Dispose methods from its own Dispose method.</value>
  </data>
  <data name="S2931_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2931_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2931_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S2931_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S2931_Tags" xml:space="preserve">
    <value>cwe,denial-of-service,bug</value>
  </data>
  <data name="S2931_Title" xml:space="preserve">
    <value>Classes with "IDisposable" members should implement "IDisposable"</value>
  </data>
  <data name="S2933_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2933_Description" xml:space="preserve">
    <value>readonly fields can only be assigned in a class constructor. If a class has a field that's not marked readonly but is only set in the constructor, it could cause confusion about the field's intended use. To avoid confusion, such fields should be marked readonly to make their intended use explicit, and to prevent future maintainers from inadvertently changing their use.</value>
  </data>
  <data name="S2933_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2933_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2933_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S2933_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2933_Tags" xml:space="preserve">
    <value>confusing</value>
  </data>
  <data name="S2933_Title" xml:space="preserve">
    <value>Fields that are only assigned in the constructor should be "readonly"</value>
  </data>
  <data name="S2934_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2934_Description" xml:space="preserve">
    <value>While the properties of a readonly reference type field can still be changed after initialization, those of a readonly value field, such as a struct, cannot. </value>
  </data>
  <data name="S2934_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2934_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2934_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S2934_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2934_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S2934_Title" xml:space="preserve">
    <value>Property assignments should not be made for "readonly" fields not constrained to reference types</value>
  </data>
  <data name="S2952_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2952_Description" xml:space="preserve">
    <value>It is possible in an IDisposable to call Dispose on class members from any method, but the contract of Dispose is that it will clean up all unmanaged resources. Move disposing of members to some other method, and you risk resource leaks.</value>
  </data>
  <data name="S2952_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2952_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2952_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S2952_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S2952_Tags" xml:space="preserve">
    <value>cwe,denial-of-service,bug</value>
  </data>
  <data name="S2952_Title" xml:space="preserve">
    <value>Classes should "Dispose" of members from the classes' own "Dispose" methods</value>
  </data>
  <data name="S2953_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2953_Description" xml:space="preserve">
    <value>Dispose as a method name should be used exclusively to implement IDisposable.Dispose to prevent any confusion.</value>
  </data>
  <data name="S2953_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2953_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2953_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S2953_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S2953_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S2953_Title" xml:space="preserve">
    <value>Methods named "Dispose" should implement "IDisposable.Dispose"</value>
  </data>
  <data name="S2955_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2955_Description" xml:space="preserve">
    <value>When constraints have not been applied to restrict a generic type parameter to be a reference type, then a value type, such as a struct, could also be passed. In such cases, comparing the type parameter to null would always be false, because a struct can be empty, but never null. If a value type is truly what's expected, then the comparison should use default(). If it's not, then constraints should be added so that no value type can be passed.</value>
  </data>
  <data name="S2955_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S2955_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2955_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S2955_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S2955_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S2955_Title" xml:space="preserve">
    <value>Generic parameters not constrained to reference types should not be compared to "null"</value>
  </data>
  <data name="S2971_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S2971_Description" xml:space="preserve">
    <value>In the interests of readability, code that can be simplified should be simplified. To that end, there are several ways IEnumerable LINQs can be simplified</value>
  </data>
  <data name="S2971_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2971_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2971_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2971_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2971_Tags" xml:space="preserve">
    <value>clumsy</value>
  </data>
  <data name="S2971_Title" xml:space="preserve">
    <value>"IEnumerable" LINQs should be simplified</value>
  </data>
  <data name="S2995_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2995_Description" xml:space="preserve">
    <value>Using Object.ReferenceEquals to compare the references of two value types simply won't return the expected results most of the time because such types are passed by value, not by reference.</value>
  </data>
  <data name="S2995_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2995_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2995_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S2995_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2995_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S2995_Title" xml:space="preserve">
    <value>"Object.ReferenceEquals" should not be used for value types</value>
  </data>
  <data name="S2996_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2996_Description" xml:space="preserve">
    <value>When an object has a field annotated with ThreadStatic, that field is shared within a given thread, but unique across threads. Since a class' static initializer is only invoked for the first thread created, it also means that only the first thread will have the expected initial values.</value>
  </data>
  <data name="S2996_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2996_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2996_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S2996_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2996_Tags" xml:space="preserve">
    <value>multi-threading,bug</value>
  </data>
  <data name="S2996_Title" xml:space="preserve">
    <value>"ThreadStatic" fields should not be initialized</value>
  </data>
  <data name="S2997_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S2997_Description" xml:space="preserve">
    <value>Typically you want to use using to create a local IDisposable variable; it will trigger disposal of the object when control passes out of the block's scope. The exception to this rule is when your method returns that IDisposable. In that case using disposes of the object before the caller can make use of it, likely causing exceptions at runtime. So you should either remove using or avoid returning the IDisposable.</value>
  </data>
  <data name="S2997_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S2997_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S2997_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S2997_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S2997_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S2997_Title" xml:space="preserve">
    <value>"IDisposables" created in a "using" statement should not be returned</value>
  </data>
  <data name="S3005_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3005_Description" xml:space="preserve">
    <value>When a non-static class field is annotated with ThreadStatic, the code seems to show that the field can have different values for different calling threads, but that's not the case, since the ThreadStatic attribute is simply ignored on non-static fields. </value>
  </data>
  <data name="S3005_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3005_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3005_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3005_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3005_Tags" xml:space="preserve">
    <value>bug,unused</value>
  </data>
  <data name="S3005_Title" xml:space="preserve">
    <value>"ThreadStatic" should not be used on non-static fields</value>
  </data>
  <data name="S3010_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3010_Description" xml:space="preserve">
    <value>Assigning a value to a static field in a constructor could cause unreliable behavior at runtime since it will change the value for all instances of the class.</value>
  </data>
  <data name="S3010_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3010_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3010_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S3010_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3010_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S3010_Title" xml:space="preserve">
    <value>Static fields should not be updated in constructors</value>
  </data>
  <data name="S3052_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3052_Description" xml:space="preserve">
    <value>The compiler automatically initializes class fields, auto-properties and events to their default values before setting them with any initialization values, so there is no need to explicitly set a member to its default value. Further, under the logic that cleaner code is better code, it's considered poor style to do so.</value>
  </data>
  <data name="S3052_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3052_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3052_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3052_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3052_Tags" xml:space="preserve">
    <value>convention,finding</value>
  </data>
  <data name="S3052_Title" xml:space="preserve">
    <value>Members should not be initialized to default values</value>
  </data>
  <data name="S3168_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3168_Description" xml:space="preserve">
    <value>An async method with a void return type is a "fire and forget" method best reserved for event handlers because there's no way to wait for the method's execution to complete and respond accordingly. There's also no way to catch exceptions thrown from the method.</value>
  </data>
  <data name="S3168_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3168_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3168_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S3168_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3168_Tags" xml:space="preserve">
    <value>multi-threading,bug</value>
  </data>
  <data name="S3168_Title" xml:space="preserve">
    <value>"async" methods should not return "void"</value>
  </data>
  <data name="S3169_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3169_Description" xml:space="preserve">
    <value>There's no point in chaining multiple OrderBy calls in a LINQ; only the last one will be reflected in the result because each subsequent call completely reorders the list. Thus, calling OrderBy multiple times is a performance issue as well, because all of the sorting will be executed, but only the result of the last sort will be kept.</value>
  </data>
  <data name="S3169_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3169_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3169_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3169_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3169_Tags" xml:space="preserve">
    <value>performance</value>
  </data>
  <data name="S3169_Title" xml:space="preserve">
    <value>Multiple "OrderBy" calls should not be used</value>
  </data>
  <data name="S3172_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3172_Description" xml:space="preserve">
    <value>In C#, delegates can be added together to chain their execution, and subtracted to remove their execution from the chain.</value>
  </data>
  <data name="S3172_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3172_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3172_RemediationCost" xml:space="preserve">
    <value>30min</value>
  </data>
  <data name="S3172_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3172_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S3172_Title" xml:space="preserve">
    <value>Delegates should not be subtracted</value>
  </data>
  <data name="S3215_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3215_Description" xml:space="preserve">
    <value>Needing to cast from an interface to a concrete type indicates that something is wrong with the abstractions in use, likely that something is missing from the interface. Instead of casting to a discrete type, the missing functionality should be added to the interface. Otherwise there is a risk of runtime exceptions.</value>
  </data>
  <data name="S3215_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3215_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3215_RemediationCost" xml:space="preserve">
    <value>1h</value>
  </data>
  <data name="S3215_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S3215_Tags" xml:space="preserve">
    <value>design</value>
  </data>
  <data name="S3215_Title" xml:space="preserve">
    <value>"interface" instances should not be cast to concrete types</value>
  </data>
  <data name="S3216_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3216_Description" xml:space="preserve">
    <value>After an awaited Task has executed, you can continue execution in the original, calling thread or any arbitrary thread. Unless the rest of the code needs the context from which the Task was spawned, Task.ConfigureAwait(false) should be used to keep execution in the Task thread to avoid the need for context switching and the possibility of deadlocks.</value>
  </data>
  <data name="S3216_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3216_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3216_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S3216_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S3216_Tags" xml:space="preserve">
    <value>multi-threading,suspicious</value>
  </data>
  <data name="S3216_Title" xml:space="preserve">
    <value>"ConfigureAwait(false)" should be used</value>
  </data>
  <data name="S3217_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3217_Description" xml:space="preserve">
    <value>The foreach statement was introduced in the C# language prior to generics to make it easier to work with the non-generic collections available at that time such as ArrayList. The foreach statements allows you to downcast elements of a collection of Objects to any other type. The problem is that to achieve the cast, the foreach statements silently performs explicit type conversion, which at runtime can result in an InvalidCastException.</value>
  </data>
  <data name="S3217_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3217_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3217_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S3217_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S3217_Tags" xml:space="preserve">
    <value>suspicious</value>
  </data>
  <data name="S3217_Title" xml:space="preserve">
    <value>"Explicit" conversions of "foreach" loops should not be used</value>
  </data>
  <data name="S3218_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3218_Description" xml:space="preserve">
    <value>It's possible to name the members of an inner class the same as the static members of its enclosing class - possible, but a bad idea. That's because maintainers may be confused about which members are being used where. Instead the inner class' members should be renamed and all the references updated.</value>
  </data>
  <data name="S3218_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3218_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3218_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S3218_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S3218_Tags" xml:space="preserve">
    <value>design,cert,pitfall</value>
  </data>
  <data name="S3218_Title" xml:space="preserve">
    <value>Inner class members should not shadow outer class "static" or type members</value>
  </data>
  <data name="S3220_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3220_Description" xml:space="preserve">
    <value>The rules for method resolution are complex and perhaps not properly understood by all coders. The params keyword can make method declarations overlap in non-obvious ways, so that slight changes in the argument types of an invocation can resolve to different methods.</value>
  </data>
  <data name="S3220_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3220_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3220_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S3220_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3220_Tags" xml:space="preserve">
    <value>bug,pitfall</value>
  </data>
  <data name="S3220_Title" xml:space="preserve">
    <value>Method calls should not resolve ambiguously to overloads with "params"</value>
  </data>
  <data name="S3234_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3234_Description" xml:space="preserve">
    <value>GC.SuppressFinalize asks the Common Language Runtime not to call the finalizer of an object. This is useful when implementing the dispose pattern where object finalization is already handled in IDisposable.Dispose. However, it has no effect if there is no finalizer defined in the object's type, so using it in such cases is just confusing.</value>
  </data>
  <data name="S3234_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3234_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3234_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3234_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3234_Tags" xml:space="preserve">
    <value>unused,confusing</value>
  </data>
  <data name="S3234_Title" xml:space="preserve">
    <value>"GC.SuppressFinalize" should not be invoked for types without destructors</value>
  </data>
  <data name="S3235_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3235_Description" xml:space="preserve">
    <value>Redundant parentheses are simply wasted keystrokes, and should be removed.</value>
  </data>
  <data name="S3235_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3235_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3235_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3235_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3235_Tags" xml:space="preserve">
    <value>cert,unused,finding</value>
  </data>
  <data name="S3235_Title" xml:space="preserve">
    <value>Redundant parentheses should not be used</value>
  </data>
  <data name="S3236_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3236_Description" xml:space="preserve">
    <value>Caller information attributes: CallerFilePathAttribute and CallerLineNumberAttribute provide a way to get information about the caller of a method through optional parameters. But the arguments for these optional parameters are only generated if they are not explicitly defined in the call. Thus, specifying the argument values defeats the purpose of the attributes.</value>
  </data>
  <data name="S3236_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3236_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3236_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3236_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3236_Tags" xml:space="preserve">
    <value>suspicious</value>
  </data>
  <data name="S3236_Title" xml:space="preserve">
    <value>Caller information arguments should not be provided explicitly</value>
  </data>
  <data name="S3237_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3237_Description" xml:space="preserve">
    <value>In property and indexer set methods, and in event add and remove methods, the implicit value parameter holds the value the accessor was called with. Not using the value means that the accessor ignores the caller's intent which could cause unexpected results at runtime.</value>
  </data>
  <data name="S3237_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3237_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3237_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3237_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S3237_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S3237_Title" xml:space="preserve">
    <value>"value" parameters should be used</value>
  </data>
  <data name="S3240_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3240_Description" xml:space="preserve">
    <value>In the interests of keeping code clean, the simplest possible conditional syntax should be used. That means </value>
  </data>
  <data name="S3240_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3240_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3240_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3240_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3240_Tags" xml:space="preserve">
    <value>clumsy</value>
  </data>
  <data name="S3240_Title" xml:space="preserve">
    <value>The simplest possible condition syntax should be used</value>
  </data>
  <data name="S3241_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3241_Description" xml:space="preserve">
    <value>Private methods are clearly intended for use only within their own scope. When such methods return values that are never used by any of their callers, then clearly there is no need to actually make the return, and it should be removed in the interests of efficiency and clarity. </value>
  </data>
  <data name="S3241_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3241_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3241_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3241_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3241_Tags" xml:space="preserve">
    <value>design,cert,unused</value>
  </data>
  <data name="S3241_Title" xml:space="preserve">
    <value>Methods should not return values that are never used</value>
  </data>
  <data name="S3244_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3244_Description" xml:space="preserve">
    <value>It is possible to subscribe to events with anonymous delegates, but having done so, it is impossible to unsubscribe from them. That's because the process of subscribing adds the delegate to a list. The process of unsubscribing essentially says: remove this item from the subscription list. But because an anonymous delegate was used in both cases, the unsubscribe attempt tries to remove a different item from the list than was added. The result: NOOP.</value>
  </data>
  <data name="S3244_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3244_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3244_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S3244_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3244_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S3244_Title" xml:space="preserve">
    <value>Anonymous delegates should not be used to unsubscribe from Events</value>
  </data>
  <data name="S3246_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3246_Description" xml:space="preserve">
    <value>In the interests of making code as usable as possible, interfaces and delegates with generic parameters should use the out and in modifiers when possible to make the interfaces and delegates covariant and contravariant, respectively.</value>
  </data>
  <data name="S3246_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3246_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3246_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3246_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3246_Tags" xml:space="preserve">
    <value>api-design</value>
  </data>
  <data name="S3246_Title" xml:space="preserve">
    <value>Generic type parameters should be co/contravariant when possible</value>
  </data>
  <data name="S3247_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3247_Description" xml:space="preserve">
    <value>Because the is operator performs a cast if the object is not null, using is to check type and then casting the same argument to that type, necessarily performs two casts. The same result can be achieved more efficiently with a single cast using as, followed by a null-check.</value>
  </data>
  <data name="S3247_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3247_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3247_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S3247_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3247_Tags" xml:space="preserve">
    <value>performance</value>
  </data>
  <data name="S3247_Title" xml:space="preserve">
    <value>Duplicate casts should not be made</value>
  </data>
  <data name="S3249_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3249_Description" xml:space="preserve">
    <value>Making a base call in an overriding method is generally a good idea, but not in GetHashCode and Equals for classes that directly extend object because those methods are based on the object reference. Meaning that no two objects that use those base methods will ever be equal or have the same hash.</value>
  </data>
  <data name="S3249_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3249_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3249_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S3249_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3249_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S3249_Title" xml:space="preserve">
    <value>Classes directly extending "object" should not call "base" in "GetHashCode" or "Equals"</value>
  </data>
  <data name="S3251_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3251_Description" xml:space="preserve">
    <value>partial methods allow an increased degree of flexibility in programming a system. Hooks can be added to generated code by invoking methods that define their signature, but might not have an implementation yet. But if the implementation is still missing when the code makes it to production, the compiler silently removes the call. In the best case scenario, such calls simply represent cruft, but in they worst case they are critical, missing functionality, the loss of which will lead to unexpected results at runtime.</value>
  </data>
  <data name="S3251_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3251_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3251_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S3251_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3251_Tags" xml:space="preserve">
    <value>suspicious</value>
  </data>
  <data name="S3251_Title" xml:space="preserve">
    <value>Implementations should be provided for "partial" methods</value>
  </data>
  <data name="S3253_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3253_Description" xml:space="preserve">
    <value>Since the compiler will automatically invoke the base type's no-argument constructor, there's no need to specify its invocation explicitly. Also, when only a single public parameterless constructor is defined in a class, then that constructor can be removed because the compiler would generate it automatically. Similarly, empty static constructors and empty destructors are also wasted keystrokes.</value>
  </data>
  <data name="S3253_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3253_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3253_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3253_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3253_Tags" xml:space="preserve">
    <value>finding,clumsy</value>
  </data>
  <data name="S3253_Title" xml:space="preserve">
    <value>Constructor and destructor declarations should not be redundant</value>
  </data>
  <data name="S3254_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3254_Description" xml:space="preserve">
    <value>Specifying the default parameter values in a method call is redundant. Such values should be omitted in the interests of readability.</value>
  </data>
  <data name="S3254_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3254_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3254_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3254_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3254_Tags" xml:space="preserve">
    <value>finding,clumsy</value>
  </data>
  <data name="S3254_Title" xml:space="preserve">
    <value>Default parameter values should not be passed as arguments</value>
  </data>
  <data name="S3256_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3256_Description" xml:space="preserve">
    <value>Using string.Equals to determine if a string is empty is significantly slower than using string.IsNullOrEmpty() or checking for string.Length == 0. string.IsNullOrEmpty() is both clear and concise, and therefore preferred to laborious, error-prone, manual null- and emptiness-checking.</value>
  </data>
  <data name="S3256_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3256_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3256_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3256_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3256_Tags" xml:space="preserve">
    <value>clumsy</value>
  </data>
  <data name="S3256_Title" xml:space="preserve">
    <value>"string.IsNullOrEmpty" should be used</value>
  </data>
  <data name="S3257_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3257_Description" xml:space="preserve">
    <value>Unnecessarily verbose declarations and initializations make it harder to read the code, and should be simplified.</value>
  </data>
  <data name="S3257_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3257_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3257_RemediationCost" xml:space="preserve">
    <value>1min</value>
  </data>
  <data name="S3257_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3257_Tags" xml:space="preserve">
    <value>finding,clumsy</value>
  </data>
  <data name="S3257_Title" xml:space="preserve">
    <value>Declarations and initializations should be as concise as possible</value>
  </data>
  <data name="S3261_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3261_Description" xml:space="preserve">
    <value>Namespaces with no lines of code clutter a project and should be removed. </value>
  </data>
  <data name="S3261_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3261_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3261_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3261_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3261_Tags" xml:space="preserve">
    <value>cert,unused</value>
  </data>
  <data name="S3261_Title" xml:space="preserve">
    <value>Namespaces should not be empty</value>
  </data>
  <data name="S3262_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3262_Description" xml:space="preserve">
    <value>Overriding methods automatically inherit the params behavior. To ease readability, this modifier should be explicitly used in the overriding method as well.</value>
  </data>
  <data name="S3262_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3262_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3262_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3262_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3262_Tags" xml:space="preserve">
    <value>confusing</value>
  </data>
  <data name="S3262_Title" xml:space="preserve">
    <value>"params" should be used on overrides</value>
  </data>
  <data name="S3263_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3263_Description" xml:space="preserve">
    <value>Static field initializers are executed in the order in which they appear in the class from top to bottom. Thus, placing a static field in a class above the field or fields required for its initialization will yield unexpected results.</value>
  </data>
  <data name="S3263_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3263_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3263_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3263_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3263_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S3263_Title" xml:space="preserve">
    <value>Static fields should appear in the order they must be initialized </value>
  </data>
  <data name="S3264_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3264_Description" xml:space="preserve">
    <value>Events that are not invoked anywhere are dead code, and there's no good reason to keep them in the source.</value>
  </data>
  <data name="S3264_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3264_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3264_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S3264_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3264_Tags" xml:space="preserve">
    <value>unused</value>
  </data>
  <data name="S3264_Title" xml:space="preserve">
    <value>Events should be invoked</value>
  </data>
  <data name="S3265_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3265_Description" xml:space="preserve">
    <value>enums are usually used to identify distinct elements in a set of values. However enums can be treated as bit fields and bitwise operations can be used on them to combine the values. This is a good way of specifying multiple elements of set with a single value. When enums are used this way, it is a best practice to mark the enum with the FlagsAttribute.</value>
  </data>
  <data name="S3265_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3265_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3265_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3265_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S3265_Tags" xml:space="preserve">
    <value>convention</value>
  </data>
  <data name="S3265_Title" xml:space="preserve">
    <value>Non-flags enums should not be used in bitwise operations</value>
  </data>
  <data name="S3376_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3376_Description" xml:space="preserve">
    <value>Adherence to the standard naming conventions makes your code not only more readable, but more usable. For instance, class FirstAttribute : Attribute can be used simply with First, but you must use the full name for class AttributeOne : Attribute.</value>
  </data>
  <data name="S3376_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3376_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3376_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3376_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3376_Tags" xml:space="preserve">
    <value>convention</value>
  </data>
  <data name="S3376_Title" xml:space="preserve">
    <value>Attribute, EventArgs, and Exception type names should end with the type being extended</value>
  </data>
  <data name="S3397_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3397_Description" xml:space="preserve">
    <value>object.Equals() overrides can be optimized by checking first for reference equality between this and the parameter. This check can be implemented by calling object.ReferenceEquals() or base.Equals(), where base is object. However, using base.Equals() is a maintenance hazard because while it works if you extend Object directly, if you introduce a new base class that overrides Equals, it suddenly stops working.</value>
  </data>
  <data name="S3397_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3397_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3397_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3397_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3397_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S3397_Title" xml:space="preserve">
    <value>"base.Equals" should not be used to check for reference equality in "Equals" if "base" is not "object"</value>
  </data>
  <data name="S3427_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3427_Description" xml:space="preserve">
    <value>The rules for method resolution are complex and perhaps not properly understood by all coders. Having overloads with optional parameter values makes the matter even harder to understand. </value>
  </data>
  <data name="S3427_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3427_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3427_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S3427_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S3427_Tags" xml:space="preserve">
    <value>unused,pitfall</value>
  </data>
  <data name="S3427_Title" xml:space="preserve">
    <value>Method overloads with default parameter values should not overlap </value>
  </data>
  <data name="S3440_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3440_Description" xml:space="preserve">
    <value>There's no point in checking a variable against the value you're about to assign it. Save the cycles and lines of code, and simply perform the assignment.</value>
  </data>
  <data name="S3440_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3440_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3440_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3440_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3440_Tags" xml:space="preserve">
    <value>confusing</value>
  </data>
  <data name="S3440_Title" xml:space="preserve">
    <value>Variables should not be checked against the values they're about to be assigned</value>
  </data>
  <data name="S3441_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3441_Description" xml:space="preserve">
    <value>When an anonymous type's properties are copied from properties or variables with the same names, it yields cleaner code to omit the new type's property name and the assignment operator.</value>
  </data>
  <data name="S3441_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3441_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3441_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3441_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3441_Tags" xml:space="preserve">
    <value>finding,clumsy</value>
  </data>
  <data name="S3441_Title" xml:space="preserve">
    <value>Redundant property names should be omitted in anonymous classes</value>
  </data>
  <data name="S3442_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3442_Description" xml:space="preserve">
    <value>Since abstract classes can't be instantiated, there's no point in their having public or internal constructors. If there is basic initialization logic that should run when an extending class instance is created, you can by all means put it in a constructor, but make that constructor private or protected.</value>
  </data>
  <data name="S3442_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3442_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3442_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3442_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3442_Tags" xml:space="preserve">
    <value>confusing</value>
  </data>
  <data name="S3442_Title" xml:space="preserve">
    <value>"abstract" classes should not have "public" constructors</value>
  </data>
  <data name="S3443_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3443_Description" xml:space="preserve">
    <value>If you call GetType() on a Type variable, the return value will always be typeof(System.Type). So there's no real point in making that call. The same applies to passing a type argument to IsInstanceOfType. In both cases the results are entirely predictable.</value>
  </data>
  <data name="S3443_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3443_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3443_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3443_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S3443_Tags" xml:space="preserve">
    <value>suspicious</value>
  </data>
  <data name="S3443_Title" xml:space="preserve">
    <value>Type should not be examined on "System.Type" instances</value>
  </data>
  <data name="S3444_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3444_Description" xml:space="preserve">
    <value>When an interface inherits from two interfaces that both define a member with the same name, trying to access that member through the derived interface will result in the compiler error CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'.</value>
  </data>
  <data name="S3444_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3444_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3444_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3444_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3444_Tags" xml:space="preserve">
    <value>design</value>
  </data>
  <data name="S3444_Title" xml:space="preserve">
    <value>Interfaces should not simply inherit from base interfaces with colliding members</value>
  </data>
  <data name="S3445_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3445_Description" xml:space="preserve">
    <value>When rethrowing an exception, you should do it by simply calling throw; and not throw exc;, because the stack trace is reset with the second syntax, making debugging a lot harder.</value>
  </data>
  <data name="S3445_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3445_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3445_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3445_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3445_Tags" xml:space="preserve">
    <value>error-handling,confusing</value>
  </data>
  <data name="S3445_Title" xml:space="preserve">
    <value>Exceptions should not be explicitly rethrown</value>
  </data>
  <data name="S3447_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3447_Description" xml:space="preserve">
    <value>The use of ref or out in combination with [Optional] is both confusing and contradictory. [Optional] indicates that the parameter doesn't have to be provided, while out and ref mean that the parameter will be used to return data to the caller (ref additionally indicates that the parameter may also be used to pass data into the method).</value>
  </data>
  <data name="S3447_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3447_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3447_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3447_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S3447_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S3447_Title" xml:space="preserve">
    <value>"[Optional]" should not be used on "ref" or "out" parameters</value>
  </data>
  <data name="S3449_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3449_Description" xml:space="preserve">
    <value>Numbers can be shifted with the &amp;lt;&amp;lt; and &amp;gt;&amp;gt; operators, but the right operand of the operation needs to be an int or a type that has an implicit conversion to int. However, with dynamic, the compiler's type checking is turned off, so you can pass anything to a shift operator and have it compile. And if the argument can't be converted to int at runtime, then a RuntimeBinderException will be raised.</value>
  </data>
  <data name="S3449_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3449_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3449_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S3449_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S3449_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S3449_Title" xml:space="preserve">
    <value>Right operands of shift operators should be integers</value>
  </data>
  <data name="S3450_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3450_Description" xml:space="preserve">
    <value>There is no point in providing a default value for a parameter if callers are required to provide a value for it anyway. Thus, [DefaultParameterValue] should always be used in conjunction with [Optional].</value>
  </data>
  <data name="S3450_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3450_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3450_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3450_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3450_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S3450_Title" xml:space="preserve">
    <value>Parameters with "[DefaultParameterValue]" attributes should also be marked "[Optional]"</value>
  </data>
  <data name="S3451_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3451_Description" xml:space="preserve">
    <value>The use of [DefaultValue] with [Optional] has no more effect than [Optional] alone. That's because [DefaultValue] doesn't actually do anything; it merely indicates the intent for the value. More than likely, [DefaultValue] was used in confusion instead of [DefaultParameterValue].</value>
  </data>
  <data name="S3451_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3451_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3451_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3451_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S3451_Tags" xml:space="preserve">
    <value>suspicious</value>
  </data>
  <data name="S3451_Title" xml:space="preserve">
    <value>"[DefaultValue]" should not be used when "[DefaultParameterValue]" is meant</value>
  </data>
  <data name="S3453_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3453_Description" xml:space="preserve">
    <value>A class with only private constructors can't be instantiated, thus, it seems to be pointless code.</value>
  </data>
  <data name="S3453_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3453_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3453_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3453_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3453_Tags" xml:space="preserve">
    <value>bug,design</value>
  </data>
  <data name="S3453_Title" xml:space="preserve">
    <value>Classes should not have only "private" constructors</value>
  </data>
  <data name="S3456_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3456_Description" xml:space="preserve">
    <value>ToCharArray can be omitted when the operation on the array could have been done directly on the string, such as when iterating over the characters in a string, and when accessing a character in a string via an array index. In those cases, explicit ToCharArray calls should be omitted.</value>
  </data>
  <data name="S3456_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3456_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3456_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3456_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3456_Tags" xml:space="preserve">
    <value>bug,clumsy</value>
  </data>
  <data name="S3456_Title" xml:space="preserve">
    <value>"string.ToCharArray()" should not be called redundantly</value>
  </data>
  <data name="S3457_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3457_Description" xml:space="preserve">
    <value>Because composite format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to unexpected behaviors or runtime errors. This rule statically validates the good behavior of composite formats when calling the methods of String.Format, StringBuilder.AppendFormat, Console.Write, Console.WriteLine, TextWriter.Write, TextWriter.WriteLine, Debug.WriteLine(String, Object[]), Trace.TraceError(String, Object[]), Trace.TraceInformation(String, Object[]), Trace.TraceWarning(String, Object[]) and TraceSource.TraceInformation(String, Object[]). </value>
  </data>
  <data name="S3457_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3457_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3457_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S3457_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3457_Tags" xml:space="preserve">
    <value>cert,confusing</value>
  </data>
  <data name="S3457_Title" xml:space="preserve">
    <value>Composite format strings should be used correctly</value>
  </data>
  <data name="S3458_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3458_Description" xml:space="preserve">
    <value>Empty case clauses that fall through to the default are useless. Whether or not such a case is present, the default clause will be invoked. Such cases simply clutter the code, and should be removed.</value>
  </data>
  <data name="S3458_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3458_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3458_RemediationCost" xml:space="preserve">
    <value>1min</value>
  </data>
  <data name="S3458_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3458_Tags" xml:space="preserve">
    <value>finding,clumsy</value>
  </data>
  <data name="S3458_Title" xml:space="preserve">
    <value>Empty "case" clauses that fall through to the "default" should be omitted</value>
  </data>
  <data name="S3459_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3459_Description" xml:space="preserve">
    <value>Fields and auto-properties that are never assigned to hold the default values for their types. They are either pointless code or, more likely, mistakes. </value>
  </data>
  <data name="S3459_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3459_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3459_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3459_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3459_Tags" xml:space="preserve">
    <value>suspicious</value>
  </data>
  <data name="S3459_Title" xml:space="preserve">
    <value>Unassigned members should be removed</value>
  </data>
  <data name="S3466_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3466_Description" xml:space="preserve">
    <value>Generally, writing the least code that will readably do the job is a good thing, so omitting default parameter values seems to make sense. Unfortunately, when you omit them from the base call in an override, you're not actually getting the job done thoroughly, because you're ignoring the value the caller passed in. The result will likely not be what the caller expected.</value>
  </data>
  <data name="S3466_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3466_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3466_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3466_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3466_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S3466_Title" xml:space="preserve">
    <value>Optional parameters should be passed to "base" calls</value>
  </data>
  <data name="S3532_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3532_Description" xml:space="preserve">
    <value>The default clause should take appropriate action. Having an empty default is a waste of keystrokes.</value>
  </data>
  <data name="S3532_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3532_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3532_RemediationCost" xml:space="preserve">
    <value>	1min</value>
  </data>
  <data name="S3532_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3532_Tags" xml:space="preserve">
    <value>unused,finding,clumsy</value>
  </data>
  <data name="S3532_Title" xml:space="preserve">
    <value>Empty "default" clauses should be removed</value>
  </data>
  <data name="S3597_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3597_Description" xml:space="preserve">
    <value>The ServiceContract attribute specifies that a class or interface defines the communication contract of a Windows Communication Foundation (WCF) service. The service operations of this class or interface are defined by OperationContract attributes added to methods. It doesn't make sense to define a contract without any service operations; thus, in a ServiceContract class or interface at least one method should be annotated with OperationContract. Similarly, WCF only serves OperationContract methods that are defined inside ServiceContract classes or interfaces; thus, this rule also checks that ServiceContract is added to the containing type of OperationContract methods.</value>
  </data>
  <data name="S3597_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3597_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3597_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3597_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3597_Tags" xml:space="preserve">
    <value>api-design</value>
  </data>
  <data name="S3597_Title" xml:space="preserve">
    <value>"ServiceContract" and "OperationContract" attributes should be used together</value>
  </data>
  <data name="S3598_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3598_Description" xml:space="preserve">
    <value>When declaring a Windows Communication Foundation (WCF) OperationContract method one-way, that service method won't return any result, not even an underlying empty confirmation message. These are fire-and-forget methods that are useful in event-like communication. Specifying a return type therefore does not make sense.</value>
  </data>
  <data name="S3598_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3598_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3598_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S3598_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3598_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S3598_Title" xml:space="preserve">
    <value>One-way "OperationContract" methods should have "void" return type</value>
  </data>
  <data name="S3600_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3600_Description" xml:space="preserve">
    <value>Adding params to a method override has no effect. The compiler accepts it, but the callers won't be able to benefit from the added modifier.</value>
  </data>
  <data name="S3600_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3600_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3600_RemediationCost" xml:space="preserve">
    <value>1min</value>
  </data>
  <data name="S3600_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S3600_Tags" xml:space="preserve">
    <value>confusing</value>
  </data>
  <data name="S3600_Title" xml:space="preserve">
    <value>"params" should not be introduced on overrides</value>
  </data>
  <data name="S3603_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3603_Description" xml:space="preserve">
    <value>Marking a method with the [Pure] attribute specifies that the method doesn't make any visible changes; thus, the method should return a result, otherwise the call to the method should be equal to no-operation. So [Pure] on a void method is either a mistake, or the method doesn't do any meaningful task.</value>
  </data>
  <data name="S3603_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3603_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3603_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3603_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3603_Tags" xml:space="preserve">
    <value>bug</value>
  </data>
  <data name="S3603_Title" xml:space="preserve">
    <value>Methods with "Pure" attribute should return a value </value>
  </data>
  <data name="S3604_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3604_Description" xml:space="preserve">
    <value>Fields, properties and events can be initialized either inline or in the constructor. Initializing them inline and in the constructor at the same time is redundant; the inline initialization will be overridden.</value>
  </data>
  <data name="S3604_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3604_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3604_RemediationCost" xml:space="preserve">
    <value>1min</value>
  </data>
  <data name="S3604_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3604_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S3604_Title" xml:space="preserve">
    <value>Member initializer values should not be redundant</value>
  </data>
  <data name="S3610_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3610_Description" xml:space="preserve">
    <value>Calling GetType() on a nullable object returns the underlying value type. Thus, comparing the returned Type object to typeof(Nullable&amp;lt;SomeType&amp;gt;) doesn't make sense. The comparison either throws an exception or the result can be known at compile time.</value>
  </data>
  <data name="S3610_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3610_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3610_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3610_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3610_Tags" xml:space="preserve">
    <value>bug,redundant</value>
  </data>
  <data name="S3610_Title" xml:space="preserve">
    <value>Nullable type comparison should not be redundant</value>
  </data>
  <data name="S3626_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3626_Description" xml:space="preserve">
    <value>Jump statements, such as return, yield break, goto, and continue let you change the default flow of program execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes.</value>
  </data>
  <data name="S3626_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3626_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3626_RemediationCost" xml:space="preserve">
    <value>1min</value>
  </data>
  <data name="S3626_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3626_Tags" xml:space="preserve">
    <value>finding,redundant,clumsy</value>
  </data>
  <data name="S3626_Title" xml:space="preserve">
    <value>Jump statements should not be redundant</value>
  </data>
  <data name="S3655_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3655_Description" xml:space="preserve">
    <value>Nullable value types can hold either a value or null. The value held in the nullable type can be accessed with the Value property, but .Value throws an InvalidOperationException when the value is null. To avoid the exception, a nullable type should always be tested before .Value is accessed.</value>
  </data>
  <data name="S3655_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3655_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3655_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S3655_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3655_Tags" xml:space="preserve">
    <value>cwe,bug</value>
  </data>
  <data name="S3655_Title" xml:space="preserve">
    <value>Empty nullable value should not be accessed</value>
  </data>
  <data name="S3776_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3776_Description" xml:space="preserve">
    <value>Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be difficult to maintain.</value>
  </data>
  <data name="S3776_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3776_Remediation" xml:space="preserve">
    <value />
  </data>
  <data name="S3776_RemediationCost" xml:space="preserve">
    <value />
  </data>
  <data name="S3776_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S3776_Tags" xml:space="preserve">
    <value>brain-overload</value>
  </data>
  <data name="S3776_Title" xml:space="preserve">
    <value>Cognitive Complexity of methods should not be too high</value>
  </data>
  <data name="S3869_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3869_Description" xml:space="preserve">
    <value>Not surprisingly, the SafeHandle.DangerousGetHandle method is dangerous. That's because it may not return a valid handle. Using it can lead to leaks and vulnerabilities. While it is possible to use the method successfully, it's extremely difficult to do correctly, so the method should simply be avoided altogether.</value>
  </data>
  <data name="S3869_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3869_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3869_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S3869_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S3869_Tags" xml:space="preserve">
    <value>leak,unpredictable</value>
  </data>
  <data name="S3869_Title" xml:space="preserve">
    <value>"SafeHandle.DangerousGetHandle" should not be called</value>
  </data>
  <data name="S3871_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3871_Description" xml:space="preserve">
    <value>The point of having custom exception types is to convey more information than is available in standard types. But custom exception types must be public for that to work. </value>
  </data>
  <data name="S3871_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3871_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3871_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3871_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S3871_Tags" xml:space="preserve">
    <value>error-handling,api-design</value>
  </data>
  <data name="S3871_Title" xml:space="preserve">
    <value>Exception types should be "public"</value>
  </data>
  <data name="S3872_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3872_Description" xml:space="preserve">
    <value>The name of a method should communicate what it does, and the names of its parameters should indicate how they're used. If a method and its parameter have the same name it is an indication that one of these rules of thumb has been broken, if not both. Even if by some trick of language that's not the case, it is still likely to confuse callers and maintainers.</value>
  </data>
  <data name="S3872_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3872_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3872_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3872_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3872_Tags" xml:space="preserve">
    <value>convention,confusing</value>
  </data>
  <data name="S3872_Title" xml:space="preserve">
    <value>Parameter names should not duplicate the names of their methods</value>
  </data>
  <data name="S3874_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3874_Description" xml:space="preserve">
    <value>Passing a parameter by reference, which is what happens when you use the out or ref parameter modifiers, means that the method will receive a pointer to the argument, rather than the argument itself. If the argument was a value type, the method will be able to change the argument's values. If it was a reference type, then the method receives a pointer to a pointer, which is usually not what was intended. Even when it is what was intended, this is the sort of thing that's difficult to get right, and should be used with caution.</value>
  </data>
  <data name="S3874_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3874_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3874_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S3874_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S3874_Tags" xml:space="preserve">
    <value>suspicious</value>
  </data>
  <data name="S3874_Title" xml:space="preserve">
    <value>"out" and "ref" parameters should not be used</value>
  </data>
  <data name="S3875_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3875_Description" xml:space="preserve">
    <value>The use of == to compare to objects is expected to do a reference comparison. That is, it is expected to return true if and only if they are the same object instance. Overloading the operator to do anything else will inevitably lead to the introduction of bugs by callers. On the other hand, overloading it to do exactly that is pointless; that's what == does by default.</value>
  </data>
  <data name="S3875_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3875_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3875_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S3875_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S3875_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S3875_Title" xml:space="preserve">
    <value>"operator==" should not be overloaded on reference types</value>
  </data>
  <data name="S3876_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3876_Description" xml:space="preserve">
    <value>Strings and integral types are typically used as indexers. When some other type is required, it typically indicates design problems, and potentially a situation where a method should be used instead.</value>
  </data>
  <data name="S3876_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3876_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3876_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S3876_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3876_Tags" xml:space="preserve">
    <value>design</value>
  </data>
  <data name="S3876_Title" xml:space="preserve">
    <value>Strings or integral types should be used for indexers</value>
  </data>
  <data name="S3877_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3877_Description" xml:space="preserve">
    <value>It is expected that some methods should be called with caution, but others, such as ToString, are expected to "just work". Throwing an exception from such a method is likely to break callers' code unexpectedly.</value>
  </data>
  <data name="S3877_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3877_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3877_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S3877_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S3877_Tags" xml:space="preserve">
    <value>pitfall</value>
  </data>
  <data name="S3877_Title" xml:space="preserve">
    <value>Exceptions should not be thrown from unexpected methods</value>
  </data>
  <data name="S3880_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3880_Description" xml:space="preserve">
    <value>Finalizers come with a performance cost due to the overhead of tracking the life cycle of objects. An empty one is consequently costly with no benefit or justification.</value>
  </data>
  <data name="S3880_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3880_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3880_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3880_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3880_Tags" xml:space="preserve">
    <value>performance</value>
  </data>
  <data name="S3880_Title" xml:space="preserve">
    <value>Finalizers should not be empty</value>
  </data>
  <data name="S3881_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3881_Description" xml:space="preserve">
    <value>The IDisposable interface is a mechanism to release unmanaged resources, if not implemented correctly this could result in resource leaks or more severe bugs.</value>
  </data>
  <data name="S3881_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3881_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3881_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S3881_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3881_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S3881_Title" xml:space="preserve">
    <value>"IDisposable" should be implemented correctly</value>
  </data>
  <data name="S3884_Category" xml:space="preserve">
    <value>Sonar Vulnerability</value>
  </data>
  <data name="S3884_Description" xml:space="preserve">
    <value>CoSetProxyBlanket and CoInitializeSecurity both work to set the permissions context in which the process invoked immediately after is executed. Calling them from within that process is useless because it's to late at that point; the permissions context has already been set.</value>
  </data>
  <data name="S3884_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3884_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3884_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S3884_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S3884_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S3884_Title" xml:space="preserve">
    <value>"CoSetProxyBlanket" and "CoInitializeSecurity" should not be used</value>
  </data>
  <data name="S3885_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3885_Description" xml:space="preserve">
    <value>The parameter to Assembly.Load includes the full specification of the dll to be loaded. Use another method, and you might end up with a dll other than the one you expected. </value>
  </data>
  <data name="S3885_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3885_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3885_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3885_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3885_Tags" xml:space="preserve">
    <value>unpredictable</value>
  </data>
  <data name="S3885_Title" xml:space="preserve">
    <value>"Assembly.Load" should be used</value>
  </data>
  <data name="S3887_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3887_Description" xml:space="preserve">
    <value>Using the readonly keyword on a field means that it can't be changed after initialization. However, when applied to collections or arrays, that's only partly true. readonly enforces that another instance can't be assigned to the field, but it cannot keep the contents from being updated. That means that in practice, the field value really can be changed, and the use of readonly on such a field is misleading, and you're likely to not be getting the behavior you expect.</value>
  </data>
  <data name="S3887_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3887_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3887_RemediationCost" xml:space="preserve">
    <value>15min</value>
  </data>
  <data name="S3887_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3887_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S3887_Title" xml:space="preserve">
    <value>Mutable, non-private fields should not be "readonly"</value>
  </data>
  <data name="S3889_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3889_Description" xml:space="preserve">
    <value>Thread.Suspend and Thread.Resume can give unpredictable results, and both methods have been deprecated. Indeed, if Thread.Suspend is not used very carefully, a thread can be suspended while holding a lock, thus leading to a deadlock. Other safer synchronization mechanisms should be used, such as Monitor, Mutex, and Semaphore.</value>
  </data>
  <data name="S3889_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3889_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3889_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S3889_Severity" xml:space="preserve">
    <value>Blocker</value>
  </data>
  <data name="S3889_Tags" xml:space="preserve">
    <value>multi-threading,unpredictable</value>
  </data>
  <data name="S3889_Title" xml:space="preserve">
    <value>Neither "Thread.Resume" nor "Thread.Suspend" should be used</value>
  </data>
  <data name="S3897_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3897_Description" xml:space="preserve">
    <value>The IEquatable&amp;lt;T&amp;gt; interface has only one method in it: Equals(&amp;lt;T&amp;gt;). If you've already written Equals(T), there's no reason not to explicitly implement IEquatable&amp;lt;T&amp;gt;. Doing so expands the utility of your class by allowing it to be used where an IEquatable is called for.</value>
  </data>
  <data name="S3897_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3897_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3897_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3897_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3897_Tags" xml:space="preserve">
    <value>api-design</value>
  </data>
  <data name="S3897_Title" xml:space="preserve">
    <value>Classes that provide "Equals(&lt;T&gt;)" or override "Equals(Object)" should implement "IEquatable&lt;T&gt;"</value>
  </data>
  <data name="S3898_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3898_Description" xml:space="preserve">
    <value>If you're using a struct, it is likely because you're interested in performance. But by failing to implement IEquatable&amp;lt;T&amp;gt; you're loosing performance when comparisons are made because without IEquatable&amp;lt;T&amp;gt;, boxing and reflection are used to make comparisons. </value>
  </data>
  <data name="S3898_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3898_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3898_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S3898_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3898_Tags" xml:space="preserve">
    <value>performance</value>
  </data>
  <data name="S3898_Title" xml:space="preserve">
    <value>Value types should implement "IEquatable&lt;T&gt;"</value>
  </data>
  <data name="S3902_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3902_Description" xml:space="preserve">
    <value>Using Type.Assembly to get the current assembly is nearly free in terms of performance; it's a simple property access. On the other hand, Assembly.GetExecutingAssembly() can take up to 30 times as long because it walks up the call stack to find the assembly.</value>
  </data>
  <data name="S3902_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3902_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3902_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3902_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3902_Tags" xml:space="preserve">
    <value>performance</value>
  </data>
  <data name="S3902_Title" xml:space="preserve">
    <value>"Assembly.GetExecutingAssembly" should not be called</value>
  </data>
  <data name="S3903_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3903_Description" xml:space="preserve">
    <value>Types are declared in namespaces in order to prevent name collisions and as a way to organize them into the object hierarchy. Types that are defined outside any named namespace are in a global namespace that cannot be referenced in code.</value>
  </data>
  <data name="S3903_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3903_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3903_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3903_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3903_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S3903_Title" xml:space="preserve">
    <value>Types should be defined in named namespaces</value>
  </data>
  <data name="S3904_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3904_Description" xml:space="preserve">
    <value>If no AssemblyVersionAttribute is provided, the same default version will be used for every build. Since the version number is used by The .NET Framework to uniquely identify an assembly this can lead to broken dependencies.</value>
  </data>
  <data name="S3904_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3904_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3904_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3904_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S3904_Tags" xml:space="preserve">
    <value>bug,pitfall</value>
  </data>
  <data name="S3904_Title" xml:space="preserve">
    <value>Assemblies should have version information</value>
  </data>
  <data name="S3925_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3925_Description" xml:space="preserve">
    <value>The ISerializable interface is the mechanism to control the type serialization process. If not implemented correctly this could result in an invalid serialization and hard to detect bugs.</value>
  </data>
  <data name="S3925_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3925_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3925_RemediationCost" xml:space="preserve">
    <value>20min</value>
  </data>
  <data name="S3925_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S3925_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S3925_Title" xml:space="preserve">
    <value>"ISerializable" should be implemented correctly</value>
  </data>
  <data name="S3926_Category" xml:space="preserve">
    <value>Sonar Bug</value>
  </data>
  <data name="S3926_Description" xml:space="preserve">
    <value>Fields marked with System.Runtime.Serialization.OptionalFieldAttribute are serialized just like any other field. But such fields are ignored on deserialization, and retain the default values associated with their types. Therefore, deserialization event handlers should be declared to set such fields during the deserialization process.</value>
  </data>
  <data name="S3926_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3926_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3926_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S3926_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3926_Tags" xml:space="preserve">
    <value>serialization</value>
  </data>
  <data name="S3926_Title" xml:space="preserve">
    <value>Deserialization methods should be provided for "OptionalField" members</value>
  </data>
  <data name="S3928_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3928_Description" xml:space="preserve">
    <value>Some constructors of the ArgumentException, ArgumentNullException, ArgumentOutOfRangeException and DuplicateWaitObjectException classes must be fed with a valid parameter name. This rule raises an issue in two cases:</value>
  </data>
  <data name="S3928_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3928_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3928_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3928_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3928_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S3928_Title" xml:space="preserve">
    <value>Parameter names used into ArgumentException constructors should match an existing one </value>
  </data>
  <data name="S3962_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3962_Description" xml:space="preserve">
    <value>The value of a static readonly field is computed at runtime while the value of a const field is calculated at compile time, which improves performance.</value>
  </data>
  <data name="S3962_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3962_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3962_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3962_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3962_Tags" xml:space="preserve">
    <value>performance</value>
  </data>
  <data name="S3962_Title" xml:space="preserve">
    <value>"static readonly" constants should be "const" instead</value>
  </data>
  <data name="S3963_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3963_Description" xml:space="preserve">
    <value>When a static constructor serves no other purpose that initializing static fields, it comes with an unnecessary performance cost because the compiler generates a check before each static method or instance constructor invocation.</value>
  </data>
  <data name="S3963_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3963_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3963_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3963_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3963_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S3963_Title" xml:space="preserve">
    <value>"static" fields should be initialized inline</value>
  </data>
  <data name="S3967_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3967_Description" xml:space="preserve">
    <value>A jagged array is an array whose elements are arrays. It is recommended over a multidimensional array because the arrays that make up the elements can be of different sizes, which avoids wasting memory space.</value>
  </data>
  <data name="S3967_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3967_Remediation" xml:space="preserve">
    <value />
  </data>
  <data name="S3967_RemediationCost" xml:space="preserve">
    <value />
  </data>
  <data name="S3967_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S3967_Tags" xml:space="preserve">
    <value>design</value>
  </data>
  <data name="S3967_Title" xml:space="preserve">
    <value>Multidimensional arrays should not be used</value>
  </data>
  <data name="S3971_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3971_Description" xml:space="preserve">
    <value>GC.SuppressFinalize requests that the system not call the finalizer for the specified object. This should only be done when implementing Dispose as part of the Dispose Pattern.</value>
  </data>
  <data name="S3971_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S3971_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3971_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S3971_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3971_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S3971_Title" xml:space="preserve">
    <value>"GC.SuppressFinalize" should not be called</value>
  </data>
  <data name="S3993_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S3993_Description" xml:space="preserve">
    <value>When defining custom attributes System.AttributeUsageAttribute has to be used to indicate where the attribute can be applied. This will determine its valid locations in the code.</value>
  </data>
  <data name="S3993_IsActivatedByDefault" xml:space="preserve">
    <value>False</value>
  </data>
  <data name="S3993_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S3993_RemediationCost" xml:space="preserve">
    <value>5min</value>
  </data>
  <data name="S3993_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S3993_Tags" xml:space="preserve">
    <value />
  </data>
  <data name="S3993_Title" xml:space="preserve">
    <value>Custom attributes should be marked with "System.AttributeUsageAttribute"</value>
  </data>
  <data name="S818_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S818_Description" xml:space="preserve">
    <value>Using upper case literal suffixes removes the potential ambiguity between "1" (digit 1) and "l" (letter el) for declaring literals.</value>
  </data>
  <data name="S818_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S818_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S818_RemediationCost" xml:space="preserve">
    <value>2min</value>
  </data>
  <data name="S818_Severity" xml:space="preserve">
    <value>Minor</value>
  </data>
  <data name="S818_Tags" xml:space="preserve">
    <value>convention,misra,cert,pitfall</value>
  </data>
  <data name="S818_Title" xml:space="preserve">
    <value>Literal suffixes should be upper case</value>
  </data>
  <data name="S907_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S907_Description" xml:space="preserve">
    <value>goto is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such as if, for, while, continue or break should be used instead.</value>
  </data>
  <data name="S907_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S907_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S907_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S907_Severity" xml:space="preserve">
    <value>Major</value>
  </data>
  <data name="S907_Tags" xml:space="preserve">
    <value>brain-overload,misra</value>
  </data>
  <data name="S907_Title" xml:space="preserve">
    <value>"goto" statement should not be used</value>
  </data>
  <data name="S927_Category" xml:space="preserve">
    <value>Sonar Code Smell</value>
  </data>
  <data name="S927_Description" xml:space="preserve">
    <value>When the parameters to the implementation of a partial method don't match those in the signature declaration, then confusion is almost guaranteed. Either the implementer was confused when he renamed, swapped or mangled the parameter names in the implementation, or callers will be confused.</value>
  </data>
  <data name="S927_IsActivatedByDefault" xml:space="preserve">
    <value>True</value>
  </data>
  <data name="S927_Remediation" xml:space="preserve">
    <value>Constant/Issue</value>
  </data>
  <data name="S927_RemediationCost" xml:space="preserve">
    <value>10min</value>
  </data>
  <data name="S927_Severity" xml:space="preserve">
    <value>Critical</value>
  </data>
  <data name="S927_Tags" xml:space="preserve">
    <value>misra,cert,suspicious</value>
  </data>
  <data name="S927_Title" xml:space="preserve">
    <value>"partial" method parameter names should match</value>
  </data>
</root>