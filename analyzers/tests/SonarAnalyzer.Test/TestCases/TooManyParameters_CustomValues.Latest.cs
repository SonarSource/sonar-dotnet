using System;
using System.Runtime.InteropServices;

public record R(int a, int b, int c, int d, int e); // Compliant, this ParameterList syntax defines fields, not parameters

public record BaseRecord
{
    public BaseRecord(int i1, int i2, int i3, int i4) // Noncompliant
    {
    }
}

public record Extend : BaseRecord
{
    public Extend(int i1, int i2, int i3, int i4, string s1)    // Compliant, adds only one new
        : base(i1, i2, i3, i4)
    {
    }

    public Extend(int i1, int i2, int i3, int i4, string s1, string s2, string s3, string s4)   // Noncompliant {{Constructor has 4 new parameters, which is greater than the 3 authorized.}}
        : base(i1, i2, i3, i4)
    {
    }
}
public class TooManyParameters : If
{
    public static void F1(int p1, int p2, int p3) { }

    public static void F2(int p1, int p2, int p3, int p4) { } // Compliant, interface implementation

    public static void F1(int p1, int p2, int p3, int p4) { } // Noncompliant {{Method has 4 parameters, which is greater than the 3 authorized.}}
}

public interface If
{
    static abstract void F1(int p1, int p2, int p3);
    static abstract void F2(int p1, int p2, int p3, int p4); // Noncompliant
}

public unsafe partial class LibraryImportAttributeImports
{
    [LibraryImport("foo.dll")]
    public static partial void ExternWithoutMarshaling(int p1, int p2, int p3, int p4); // Compliant, external definition

    // Provide the implementation usually generated by the source generator:
    // Copy the partial definition with the LibraryImport attribute to a .Net 7 file and use GotoDefinition to see the generated code
    [System.Runtime.InteropServices.DllImportAttribute("foo.dll", EntryPoint = "Extern", ExactSpelling = true)]
    public static extern partial void ExternWithoutMarshaling(int p1, int p2, int p3, int p4);

    [LibraryImport("nativelib", EntryPoint = "ExternWithMarshaling", StringMarshalling = StringMarshalling.Utf16)]
    internal static partial string ExternWithMarshaling(string str, int p1, int p2, int p3, int p4); // Compliant, external definition

    // Provide the implementation usually generated by the source generator.
    // Copy the partial definition with the LibraryImport attribute to a .Net 7 file and use GotoDefinition to see the generated code
    [System.Runtime.CompilerServices.SkipLocalsInitAttribute]
    internal static partial string ExternWithMarshaling(string str, int p1, int p2, int p3, int p4)
    {
        string __retVal;
        ushort* __retVal_native = default;
        try
        {
            // Pin - Pin data in preparation for calling the P/Invoke.
            fixed (void* __str_native = &global::System.Runtime.InteropServices.Marshalling.Utf16StringMarshaller.GetPinnableReference(str))
            {
                __retVal_native = __PInvoke((ushort*)__str_native, p1, p2, p3, p4);
            }

            // Unmarshal - Convert native data to managed data.
            __retVal = global::System.Runtime.InteropServices.Marshalling.Utf16StringMarshaller.ConvertToManaged(__retVal_native);
        }
        finally
        {
            // Cleanup - Perform required cleanup.
            global::System.Runtime.InteropServices.Marshalling.Utf16StringMarshaller.Free(__retVal_native);
        }

        return __retVal;
        // Local P/Invoke
        [System.Runtime.InteropServices.DllImportAttribute("nativelib", EntryPoint = "ExternWithMarshaling", ExactSpelling = true)]
        static extern unsafe ushort* __PInvoke(ushort* str, int p1, int p2, int p3, int p4);
    }
}

// https://github.com/SonarSource/sonar-dotnet/issues/8156
namespace Repro_8156
{
    using System.Runtime.CompilerServices;

    class ZeroOverheadMemberAccess
    {
        [UnsafeAccessor(UnsafeAccessorKind.Constructor)]
        extern static UserData CallConstructor(int x1, int x2, int x3, int x4);                 // Compliant: signature has to match target

        [UnsafeAccessorAttribute(UnsafeAccessorKind.Method, Name = "Method")]
        extern static void CallMethod(UserData userData, int x1, int x2, int x3, int x4);       // Compliant: signature has to match target

        [UnsafeAccessor(UnsafeAccessorKind.StaticMethod, Name = "StaticMethod")]
        extern static void CallStaticMethod(UserData userData, int x1, int x2, int x3, int x4); // Compliant: signature has to match target
    }

    class UserData
    {
        UserData(int x1, int x2, int x3, int x4) { }         // Noncompliant

        void Method(int x1, int x2, int x3) { }              // Compliant
        static void StaticMethod(int x1, int x2, int x3) { } // Compliant
    }
}

public class MyWrongClass(int p1, int p2, int p3, int p4) { } // Noncompliant {{Constructor has 4 parameters, which is greater than the 3 authorized.}}

public class SubClass(int p1, int p2, int p3, int p4) : MyWrongClass(p1, p2, p3, p4) { } // Compliant: base class requires them

public class SubClass2() : MyWrongClass(1, 2, 3, 4) // Compliant
{
    public SubClass2(int p1, int p2, int p3, int p4, int p5) : this() { } // Noncompliant

    void Method()
    {
        var a = (int p1 = 1, int p2 = 2, int p3 = 3, int p4 = 4) => true; // Noncompliant {{Lambda has 4 parameters, which is greater than the 3 authorized.}}
    }
}

public struct MyWrongStruct(int p1, int p2, int p3, int p4) { } // Noncompliant {{Constructor has 4 parameters, which is greater than the 3 authorized.}}
