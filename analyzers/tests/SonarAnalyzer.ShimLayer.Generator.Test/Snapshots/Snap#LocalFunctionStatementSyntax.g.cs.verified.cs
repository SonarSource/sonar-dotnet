//<auto-generated/>
/*
 * SonarAnalyzer for .NET
 * Copyright (C) 2014-2025 SonarSource Sàrl
 * mailto:info AT sonarsource DOT com
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the Sonar Source-Available License Version 1, as published by SonarSource SA.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the Sonar Source-Available License for more details.
 *
 * You should have received a copy of the Sonar Source-Available License
 * along with this program; if not, see https://sonarsource.com/license/ssal/
 */

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Immutable;

namespace SonarAnalyzer.ShimLayer;

public readonly partial struct LocalFunctionStatementSyntaxWrapper: ISyntaxWrapper<StatementSyntax>
{
    public const string WrappedTypeName = "Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax";
    private static readonly Type WrappedType;

    private readonly StatementSyntax node;

    static LocalFunctionStatementSyntaxWrapper()
    {
        WrappedType = SyntaxNodeTypes.LatestType(typeof(LocalFunctionStatementSyntaxWrapper));
        AttributeListsAccessor = LightupHelpers.CreateSyntaxPropertyAccessor<StatementSyntax, SyntaxList<AttributeListSyntax>>(WrappedType, "AttributeLists");
        ModifiersAccessor = LightupHelpers.CreateSyntaxPropertyAccessor<StatementSyntax, SyntaxTokenList>(WrappedType, "Modifiers");
        ReturnTypeAccessor = LightupHelpers.CreateSyntaxPropertyAccessor<StatementSyntax, TypeSyntax>(WrappedType, "ReturnType");
        IdentifierAccessor = LightupHelpers.CreateSyntaxPropertyAccessor<StatementSyntax, SyntaxToken>(WrappedType, "Identifier");
        TypeParameterListAccessor = LightupHelpers.CreateSyntaxPropertyAccessor<StatementSyntax, TypeParameterListSyntax>(WrappedType, "TypeParameterList");
        ParameterListAccessor = LightupHelpers.CreateSyntaxPropertyAccessor<StatementSyntax, ParameterListSyntax>(WrappedType, "ParameterList");
        ConstraintClausesAccessor = LightupHelpers.CreateSyntaxPropertyAccessor<StatementSyntax, SyntaxList<TypeParameterConstraintClauseSyntax>>(WrappedType, "ConstraintClauses");
        BodyAccessor = LightupHelpers.CreateSyntaxPropertyAccessor<StatementSyntax, BlockSyntax>(WrappedType, "Body");
        ExpressionBodyAccessor = LightupHelpers.CreateSyntaxPropertyAccessor<StatementSyntax, ArrowExpressionClauseSyntax>(WrappedType, "ExpressionBody");
        SemicolonTokenAccessor = LightupHelpers.CreateSyntaxPropertyAccessor<StatementSyntax, SyntaxToken>(WrappedType, "SemicolonToken");
    }

    private LocalFunctionStatementSyntaxWrapper(StatementSyntax node) =>
        this.node = node;

    public StatementSyntax Node => this.node;

    [Obsolete("Use Node instead")]
    public StatementSyntax SyntaxNode => this.node;

    private static readonly Func<StatementSyntax, SyntaxList<AttributeListSyntax>> AttributeListsAccessor;
    public SyntaxList<AttributeListSyntax> AttributeLists => (SyntaxList<AttributeListSyntax>)AttributeListsAccessor(this.node);
    private static readonly Func<StatementSyntax, SyntaxTokenList> ModifiersAccessor;
    public SyntaxTokenList Modifiers => (SyntaxTokenList)ModifiersAccessor(this.node);
    private static readonly Func<StatementSyntax, TypeSyntax> ReturnTypeAccessor;
    public TypeSyntax ReturnType => ReturnTypeAccessor(this.node);
    private static readonly Func<StatementSyntax, SyntaxToken> IdentifierAccessor;
    public SyntaxToken Identifier => (SyntaxToken)IdentifierAccessor(this.node);
    private static readonly Func<StatementSyntax, TypeParameterListSyntax> TypeParameterListAccessor;
    public TypeParameterListSyntax TypeParameterList => TypeParameterListAccessor(this.node);
    private static readonly Func<StatementSyntax, ParameterListSyntax> ParameterListAccessor;
    public ParameterListSyntax ParameterList => ParameterListAccessor(this.node);
    private static readonly Func<StatementSyntax, SyntaxList<TypeParameterConstraintClauseSyntax>> ConstraintClausesAccessor;
    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses => (SyntaxList<TypeParameterConstraintClauseSyntax>)ConstraintClausesAccessor(this.node);
    private static readonly Func<StatementSyntax, BlockSyntax> BodyAccessor;
    public BlockSyntax Body => BodyAccessor(this.node);
    private static readonly Func<StatementSyntax, ArrowExpressionClauseSyntax> ExpressionBodyAccessor;
    public ArrowExpressionClauseSyntax ExpressionBody => ExpressionBodyAccessor(this.node);
    private static readonly Func<StatementSyntax, SyntaxToken> SemicolonTokenAccessor;
    public SyntaxToken SemicolonToken => (SyntaxToken)SemicolonTokenAccessor(this.node);
    public String Language => this.node.Language;
    public Int32 RawKind => this.node.RawKind;
    public TextSpan FullSpan => this.node.FullSpan;
    public TextSpan Span => this.node.Span;
    public Int32 SpanStart => this.node.SpanStart;
    public Boolean IsMissing => this.node.IsMissing;
    public Boolean IsStructuredTrivia => this.node.IsStructuredTrivia;
    public Boolean HasStructuredTrivia => this.node.HasStructuredTrivia;
    public Boolean ContainsSkippedText => this.node.ContainsSkippedText;
    public Boolean ContainsDiagnostics => this.node.ContainsDiagnostics;
    public Boolean ContainsDirectives => this.node.ContainsDirectives;
    public Boolean HasLeadingTrivia => this.node.HasLeadingTrivia;
    public Boolean HasTrailingTrivia => this.node.HasTrailingTrivia;
    public SyntaxNode Parent => this.node.Parent;
    public SyntaxTrivia ParentTrivia => this.node.ParentTrivia;
    public Boolean ContainsAnnotations => this.node.ContainsAnnotations;

    public static explicit operator LocalFunctionStatementSyntaxWrapper(SyntaxNode node)
    {
        if (node is null)
        {
            return default;
        }

        if (!IsInstance(node))
        {
            throw new InvalidCastException($"Cannot cast '{node.GetType().FullName}' to '{WrappedTypeName}'");
        }

        return new LocalFunctionStatementSyntaxWrapper((StatementSyntax)node);
    }

    public static implicit operator StatementSyntax(LocalFunctionStatementSyntaxWrapper wrapper) =>
        wrapper.node;

    public static bool IsInstance(SyntaxNode node) =>
        node is not null && LightupHelpers.CanWrapNode(node, WrappedType);
}